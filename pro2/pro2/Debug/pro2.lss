
AVRASM ver. 2.2.6  G:\comp2121\newPro2-master\pro2\pro2\main.asm Fri Jun 02 03:16:07 2017

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.1.130\avrasm\inc\m2560def.inc'
G:\comp2121\newPro2-master\pro2\pro2\main.asm(8): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.1.130\avrasm\inc\m2560def.inc'
G:\comp2121\newPro2-master\pro2\pro2\main.asm(30): Including file 'G:\comp2121\newPro2-master\pro2\pro2\macros.asm'
G:\comp2121\newPro2-master\pro2\pro2\main.asm(86): Including file 'G:\comp2121\newPro2-master\pro2\pro2\keypad.asm'
G:\comp2121\newPro2-master\pro2\pro2\main.asm(87): Including file 'G:\comp2121\newPro2-master\pro2\pro2\inventory.asm'
G:\comp2121\newPro2-master\pro2\pro2\main.asm(88): Including file 'G:\comp2121\newPro2-master\pro2\pro2\pot.asm'
G:\comp2121\newPro2-master\pro2\pro2\main.asm(630): Including file 'G:\comp2121\newPro2-master\pro2\pro2\lcd.asm'
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.1.130\avrasm\inc\m2560def.inc'
G:\comp2121\newPro2-master\pro2\pro2\main.asm(8): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.1.130\avrasm\inc\m2560def.inc'
G:\comp2121\newPro2-master\pro2\pro2\main.asm(30): Including file 'G:\comp2121\newPro2-master\pro2\pro2\macros.asm'
G:\comp2121\newPro2-master\pro2\pro2\main.asm(86): Including file 'G:\comp2121\newPro2-master\pro2\pro2\keypad.asm'
G:\comp2121\newPro2-master\pro2\pro2\main.asm(87): Including file 'G:\comp2121\newPro2-master\pro2\pro2\inventory.asm'
G:\comp2121\newPro2-master\pro2\pro2\main.asm(88): Including file 'G:\comp2121\newPro2-master\pro2\pro2\pot.asm'
G:\comp2121\newPro2-master\pro2\pro2\main.asm(630): Including file 'G:\comp2121\newPro2-master\pro2\pro2\lcd.asm'
                                 
                                 ;
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega2560.xml **********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m2560def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega2560
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega2560
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M2560DEF_INC_
                                 #define _M2560DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega2560
                                 #pragma AVRPART ADMIN PART_NAME ATmega2560
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x98
                                 .equ	SIGNATURE_002	= 0x01
                                 
                                 #pragma AVRPART CORE CORE_VERSION V3
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	UDR3	= 0x136	; MEMORY MAPPED
                                 .equ	UBRR3L	= 0x134	; MEMORY MAPPED
                                 .equ	UBRR3H	= 0x135	; MEMORY MAPPED
                                 .equ	UCSR3C	= 0x132	; MEMORY MAPPED
                                 .equ	UCSR3B	= 0x131	; MEMORY MAPPED
                                 .equ	UCSR3A	= 0x130	; MEMORY MAPPED
                                 .equ	OCR5CL	= 0x12c	; MEMORY MAPPED
                                 .equ	OCR5CH	= 0x12d	; MEMORY MAPPED
                                 .equ	OCR5BL	= 0x12a	; MEMORY MAPPED
                                 .equ	OCR5BH	= 0x12b	; MEMORY MAPPED
                                 .equ	OCR5AL	= 0x128	; MEMORY MAPPED
                                 .equ	OCR5AH	= 0x129	; MEMORY MAPPED
                                 .equ	ICR5H	= 0x127	; MEMORY MAPPED
                                 .equ	ICR5L	= 0x126	; MEMORY MAPPED
                                 .equ	TCNT5L	= 0x124	; MEMORY MAPPED
                                 .equ	TCNT5H	= 0x125	; MEMORY MAPPED
                                 .equ	TCCR5C	= 0x122	; MEMORY MAPPED
                                 .equ	TCCR5B	= 0x121	; MEMORY MAPPED
                                 .equ	TCCR5A	= 0x120	; MEMORY MAPPED
                                 .equ	PORTL	= 0x10b	; MEMORY MAPPED
                                 .equ	DDRL	= 0x10a	; MEMORY MAPPED
                                 .equ	PINL	= 0x109	; MEMORY MAPPED
                                 .equ	PORTK	= 0x108	; MEMORY MAPPED
                                 .equ	DDRK	= 0x107	; MEMORY MAPPED
                                 .equ	PINK	= 0x106	; MEMORY MAPPED
                                 .equ	PORTJ	= 0x105	; MEMORY MAPPED
                                 .equ	DDRJ	= 0x104	; MEMORY MAPPED
                                 .equ	PINJ	= 0x103	; MEMORY MAPPED
                                 .equ	PORTH	= 0x102	; MEMORY MAPPED
                                 .equ	DDRH	= 0x101	; MEMORY MAPPED
                                 .equ	PINH	= 0x100	; MEMORY MAPPED
                                 .equ	UDR2	= 0xd6	; MEMORY MAPPED
                                 .equ	UBRR2L	= 0xd4	; MEMORY MAPPED
                                 .equ	UBRR2H	= 0xd5	; MEMORY MAPPED
                                 .equ	UCSR2C	= 0xd2	; MEMORY MAPPED
                                 .equ	UCSR2B	= 0xd1	; MEMORY MAPPED
                                 .equ	UCSR2A	= 0xd0	; MEMORY MAPPED
                                 .equ	UDR1	= 0xce	; MEMORY MAPPED
                                 .equ	UBRR1L	= 0xcc	; MEMORY MAPPED
                                 .equ	UBRR1H	= 0xcd	; MEMORY MAPPED
                                 .equ	UCSR1C	= 0xca	; MEMORY MAPPED
                                 .equ	UCSR1B	= 0xc9	; MEMORY MAPPED
                                 .equ	UCSR1A	= 0xc8	; MEMORY MAPPED
                                 .equ	UDR0	= 0xc6	; MEMORY MAPPED
                                 .equ	UBRR0L	= 0xc4	; MEMORY MAPPED
                                 .equ	UBRR0H	= 0xc5	; MEMORY MAPPED
                                 .equ	UCSR0C	= 0xc2	; MEMORY MAPPED
                                 .equ	UCSR0B	= 0xc1	; MEMORY MAPPED
                                 .equ	UCSR0A	= 0xc0	; MEMORY MAPPED
                                 .equ	TWAMR	= 0xbd	; MEMORY MAPPED
                                 .equ	TWCR	= 0xbc	; MEMORY MAPPED
                                 .equ	TWDR	= 0xbb	; MEMORY MAPPED
                                 .equ	TWAR	= 0xba	; MEMORY MAPPED
                                 .equ	TWSR	= 0xb9	; MEMORY MAPPED
                                 .equ	TWBR	= 0xb8	; MEMORY MAPPED
                                 .equ	ASSR	= 0xb6	; MEMORY MAPPED
                                 .equ	OCR2B	= 0xb4	; MEMORY MAPPED
                                 .equ	OCR2A	= 0xb3	; MEMORY MAPPED
                                 .equ	TCNT2	= 0xb2	; MEMORY MAPPED
                                 .equ	TCCR2B	= 0xb1	; MEMORY MAPPED
                                 .equ	TCCR2A	= 0xb0	; MEMORY MAPPED
                                 .equ	OCR4CL	= 0xac	; MEMORY MAPPED
                                 .equ	OCR4CH	= 0xad	; MEMORY MAPPED
                                 .equ	OCR4BL	= 0xaa	; MEMORY MAPPED
                                 .equ	OCR4BH	= 0xab	; MEMORY MAPPED
                                 .equ	OCR4AL	= 0xa8	; MEMORY MAPPED
                                 .equ	OCR4AH	= 0xa9	; MEMORY MAPPED
                                 .equ	ICR4L	= 0xa6	; MEMORY MAPPED
                                 .equ	ICR4H	= 0xa7	; MEMORY MAPPED
                                 .equ	TCNT4L	= 0xa4	; MEMORY MAPPED
                                 .equ	TCNT4H	= 0xa5	; MEMORY MAPPED
                                 .equ	TCCR4C	= 0xa2	; MEMORY MAPPED
                                 .equ	TCCR4B	= 0xa1	; MEMORY MAPPED
                                 .equ	TCCR4A	= 0xa0	; MEMORY MAPPED
                                 .equ	OCR3CL	= 0x9c	; MEMORY MAPPED
                                 .equ	OCR3CH	= 0x9d	; MEMORY MAPPED
                                 .equ	OCR3BL	= 0x9a	; MEMORY MAPPED
                                 .equ	OCR3BH	= 0x9b	; MEMORY MAPPED
                                 .equ	OCR3AL	= 0x98	; MEMORY MAPPED
                                 .equ	OCR3AH	= 0x99	; MEMORY MAPPED
                                 .equ	ICR3L	= 0x96	; MEMORY MAPPED
                                 .equ	ICR3H	= 0x97	; MEMORY MAPPED
                                 .equ	TCNT3L	= 0x94	; MEMORY MAPPED
                                 .equ	TCNT3H	= 0x95	; MEMORY MAPPED
                                 .equ	TCCR3C	= 0x92	; MEMORY MAPPED
                                 .equ	TCCR3B	= 0x91	; MEMORY MAPPED
                                 .equ	TCCR3A	= 0x90	; MEMORY MAPPED
                                 .equ	OCR1CL	= 0x8c	; MEMORY MAPPED
                                 .equ	OCR1CH	= 0x8d	; MEMORY MAPPED
                                 .equ	OCR1BL	= 0x8a	; MEMORY MAPPED
                                 .equ	OCR1BH	= 0x8b	; MEMORY MAPPED
                                 .equ	OCR1AL	= 0x88	; MEMORY MAPPED
                                 .equ	OCR1AH	= 0x89	; MEMORY MAPPED
                                 .equ	ICR1L	= 0x86	; MEMORY MAPPED
                                 .equ	ICR1H	= 0x87	; MEMORY MAPPED
                                 .equ	TCNT1L	= 0x84	; MEMORY MAPPED
                                 .equ	TCNT1H	= 0x85	; MEMORY MAPPED
                                 .equ	TCCR1C	= 0x82	; MEMORY MAPPED
                                 .equ	TCCR1B	= 0x81	; MEMORY MAPPED
                                 .equ	TCCR1A	= 0x80	; MEMORY MAPPED
                                 .equ	DIDR1	= 0x7f	; MEMORY MAPPED
                                 .equ	DIDR0	= 0x7e	; MEMORY MAPPED
                                 .equ	DIDR2	= 0x7d	; MEMORY MAPPED
                                 .equ	ADMUX	= 0x7c	; MEMORY MAPPED
                                 .equ	ADCSRB	= 0x7b	; MEMORY MAPPED
                                 .equ	ADCSRA	= 0x7a	; MEMORY MAPPED
                                 .equ	ADCH	= 0x79	; MEMORY MAPPED
                                 .equ	ADCL	= 0x78	; MEMORY MAPPED
                                 .equ	XMCRB	= 0x75	; MEMORY MAPPED
                                 .equ	XMCRA	= 0x74	; MEMORY MAPPED
                                 .equ	TIMSK5	= 0x73	; MEMORY MAPPED
                                 .equ	TIMSK4	= 0x72	; MEMORY MAPPED
                                 .equ	TIMSK3	= 0x71	; MEMORY MAPPED
                                 .equ	TIMSK2	= 0x70	; MEMORY MAPPED
                                 .equ	TIMSK1	= 0x6f	; MEMORY MAPPED
                                 .equ	TIMSK0	= 0x6e	; MEMORY MAPPED
                                 .equ	PCMSK2	= 0x6d	; MEMORY MAPPED
                                 .equ	PCMSK1	= 0x6c	; MEMORY MAPPED
                                 .equ	PCMSK0	= 0x6b	; MEMORY MAPPED
                                 .equ	EICRB	= 0x6a	; MEMORY MAPPED
                                 .equ	EICRA	= 0x69	; MEMORY MAPPED
                                 .equ	PCICR	= 0x68	; MEMORY MAPPED
                                 .equ	OSCCAL	= 0x66	; MEMORY MAPPED
                                 .equ	PRR1	= 0x65	; MEMORY MAPPED
                                 .equ	PRR0	= 0x64	; MEMORY MAPPED
                                 .equ	CLKPR	= 0x61	; MEMORY MAPPED
                                 .equ	WDTCSR	= 0x60	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	EIND	= 0x3c
                                 .equ	RAMPZ	= 0x3b
                                 .equ	SPMCSR	= 0x37
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUSR	= 0x34
                                 .equ	SMCR	= 0x33
                                 .equ	OCDR	= 0x31
                                 .equ	ACSR	= 0x30
                                 .equ	SPDR	= 0x2e
                                 .equ	SPSR	= 0x2d
                                 .equ	SPCR	= 0x2c
                                 .equ	GPIOR2	= 0x2b
                                 .equ	GPIOR1	= 0x2a
                                 .equ	OCR0B	= 0x28
                                 .equ	OCR0A	= 0x27
                                 .equ	TCNT0	= 0x26
                                 .equ	TCCR0B	= 0x25
                                 .equ	TCCR0A	= 0x24
                                 .equ	GTCCR	= 0x23
                                 .equ	EEARH	= 0x22
                                 .equ	EEARL	= 0x21
                                 .equ	EEDR	= 0x20
                                 .equ	EECR	= 0x1f
                                 .equ	GPIOR0	= 0x1e
                                 .equ	EIMSK	= 0x1d
                                 .equ	EIFR	= 0x1c
                                 .equ	PCIFR	= 0x1b
                                 .equ	TIFR5	= 0x1a
                                 .equ	TIFR4	= 0x19
                                 .equ	TIFR3	= 0x18
                                 .equ	TIFR2	= 0x17
                                 .equ	TIFR1	= 0x16
                                 .equ	TIFR0	= 0x15
                                 .equ	PORTG	= 0x14
                                 .equ	DDRG	= 0x13
                                 .equ	PING	= 0x12
                                 .equ	PORTF	= 0x11
                                 .equ	DDRF	= 0x10
                                 .equ	PINF	= 0x0f
                                 .equ	PORTE	= 0x0e
                                 .equ	DDRE	= 0x0d
                                 .equ	PINE	= 0x0c
                                 .equ	PORTD	= 0x0b
                                 .equ	DDRD	= 0x0a
                                 .equ	PIND	= 0x09
                                 .equ	PORTC	= 0x08
                                 .equ	DDRC	= 0x07
                                 .equ	PINC	= 0x06
                                 .equ	PORTB	= 0x05
                                 .equ	DDRB	= 0x04
                                 .equ	PINB	= 0x03
                                 .equ	PORTA	= 0x02
                                 .equ	DDRA	= 0x01
                                 .equ	PINA	= 0x00
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; ADCSRB - ADC Control and Status Register B
                                 .equ	ACME	= 6	; Analog Comparator Multiplexer Enable
                                 
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 ; DIDR1 - Digital Input Disable Register 1
                                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                                 
                                 
                                 ; ***** USART0 ***********************
                                 ; UDR0 - USART I/O Data Register
                                 .equ	UDR0_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR0_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR0_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR0_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR0_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR0_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR0_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR0_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR0A - USART Control and Status Register A
                                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                                 .equ	U2X0	= 1	; Double the USART transmission speed
                                 .equ	UPE0	= 2	; Parity Error
                                 .equ	DOR0	= 3	; Data overRun
                                 .equ	FE0	= 4	; Framing Error
                                 .equ	UDRE0	= 5	; USART Data Register Empty
                                 .equ	TXC0	= 6	; USART Transmitt Complete
                                 .equ	RXC0	= 7	; USART Receive Complete
                                 
                                 ; UCSR0B - USART Control and Status Register B
                                 .equ	TXB80	= 0	; Transmit Data Bit 8
                                 .equ	RXB80	= 1	; Receive Data Bit 8
                                 .equ	UCSZ02	= 2	; Character Size
                                 .equ	TXEN0	= 3	; Transmitter Enable
                                 .equ	RXEN0	= 4	; Receiver Enable
                                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR0C - USART Control and Status Register C
                                 .equ	UCPOL0	= 0	; Clock Polarity
                                 .equ	UCSZ00	= 1	; Character Size
                                 .equ	UCPHA0	= UCSZ00	; For compatibility
                                 .equ	UCSZ01	= 2	; Character Size
                                 .equ	UDORD0	= UCSZ01	; For compatibility
                                 .equ	USBS0	= 3	; Stop Bit Select
                                 .equ	UPM00	= 4	; Parity Mode Bit 0
                                 .equ	UPM01	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL00	= 6	; USART Mode Select
                                 .equ	UMSEL0	= UMSEL00	; For compatibility
                                 .equ	UMSEL01	= 7	; USART Mode Select
                                 .equ	UMSEL1	= UMSEL01	; For compatibility
                                 
                                 ; UBRR0H - USART Baud Rate Register High Byte
                                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR0L - USART Baud Rate Register Low Byte
                                 .equ	_UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	_UBRR1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** TWI **************************
                                 ; TWAMR - TWI (Slave) Address Mask Register
                                 .equ	TWAM0	= 1	; 
                                 .equ	TWAMR0	= TWAM0	; For compatibility
                                 .equ	TWAM1	= 2	; 
                                 .equ	TWAMR1	= TWAM1	; For compatibility
                                 .equ	TWAM2	= 3	; 
                                 .equ	TWAMR2	= TWAM2	; For compatibility
                                 .equ	TWAM3	= 4	; 
                                 .equ	TWAMR3	= TWAM3	; For compatibility
                                 .equ	TWAM4	= 5	; 
                                 .equ	TWAMR4	= TWAM4	; For compatibility
                                 .equ	TWAM5	= 6	; 
                                 .equ	TWAMR5	= TWAM5	; For compatibility
                                 .equ	TWAM6	= 7	; 
                                 .equ	TWAMR6	= TWAM6	; For compatibility
                                 
                                 ; TWBR - TWI Bit Rate register
                                 .equ	TWBR0	= 0	; 
                                 .equ	TWBR1	= 1	; 
                                 .equ	TWBR2	= 2	; 
                                 .equ	TWBR3	= 3	; 
                                 .equ	TWBR4	= 4	; 
                                 .equ	TWBR5	= 5	; 
                                 .equ	TWBR6	= 6	; 
                                 .equ	TWBR7	= 7	; 
                                 
                                 ; TWCR - TWI Control Register
                                 .equ	TWIE	= 0	; TWI Interrupt Enable
                                 .equ	TWEN	= 2	; TWI Enable Bit
                                 .equ	TWWC	= 3	; TWI Write Collition Flag
                                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                                 .equ	TWINT	= 7	; TWI Interrupt Flag
                                 
                                 ; TWSR - TWI Status Register
                                 .equ	TWPS0	= 0	; TWI Prescaler
                                 .equ	TWPS1	= 1	; TWI Prescaler
                                 .equ	TWS3	= 3	; TWI Status
                                 .equ	TWS4	= 4	; TWI Status
                                 .equ	TWS5	= 5	; TWI Status
                                 .equ	TWS6	= 6	; TWI Status
                                 .equ	TWS7	= 7	; TWI Status
                                 
                                 ; TWDR - TWI Data register
                                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                                 
                                 ; TWAR - TWI (Slave) Address register
                                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                                 
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** PORTA ************************
                                 ; PORTA - Port A Data Register
                                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                                 .equ	PA0	= 0	; For compatibility
                                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                                 .equ	PA1	= 1	; For compatibility
                                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                                 .equ	PA2	= 2	; For compatibility
                                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                                 .equ	PA3	= 3	; For compatibility
                                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                                 .equ	PA4	= 4	; For compatibility
                                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                                 .equ	PA5	= 5	; For compatibility
                                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                                 .equ	PA6	= 6	; For compatibility
                                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                                 .equ	PA7	= 7	; For compatibility
                                 
                                 ; DDRA - Port A Data Direction Register
                                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                                 
                                 ; PINA - Port A Input Pins
                                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                                 .equ	PC7	= 7	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** PORTE ************************
                                 ; PORTE - Data Register, Port E
                                 .equ	PORTE0	= 0	; 
                                 .equ	PE0	= 0	; For compatibility
                                 .equ	PORTE1	= 1	; 
                                 .equ	PE1	= 1	; For compatibility
                                 .equ	PORTE2	= 2	; 
                                 .equ	PE2	= 2	; For compatibility
                                 .equ	PORTE3	= 3	; 
                                 .equ	PE3	= 3	; For compatibility
                                 .equ	PORTE4	= 4	; 
                                 .equ	PE4	= 4	; For compatibility
                                 .equ	PORTE5	= 5	; 
                                 .equ	PE5	= 5	; For compatibility
                                 .equ	PORTE6	= 6	; 
                                 .equ	PE6	= 6	; For compatibility
                                 .equ	PORTE7	= 7	; 
                                 .equ	PE7	= 7	; For compatibility
                                 
                                 ; DDRE - Data Direction Register, Port E
                                 .equ	DDE0	= 0	; 
                                 .equ	DDE1	= 1	; 
                                 .equ	DDE2	= 2	; 
                                 .equ	DDE3	= 3	; 
                                 .equ	DDE4	= 4	; 
                                 .equ	DDE5	= 5	; 
                                 .equ	DDE6	= 6	; 
                                 .equ	DDE7	= 7	; 
                                 
                                 ; PINE - Input Pins, Port E
                                 .equ	PINE0	= 0	; 
                                 .equ	PINE1	= 1	; 
                                 .equ	PINE2	= 2	; 
                                 .equ	PINE3	= 3	; 
                                 .equ	PINE4	= 4	; 
                                 .equ	PINE5	= 5	; 
                                 .equ	PINE6	= 6	; 
                                 .equ	PINE7	= 7	; 
                                 
                                 
                                 ; ***** PORTF ************************
                                 ; PORTF - Data Register, Port F
                                 .equ	PORTF0	= 0	; 
                                 .equ	PF0	= 0	; For compatibility
                                 .equ	PORTF1	= 1	; 
                                 .equ	PF1	= 1	; For compatibility
                                 .equ	PORTF2	= 2	; 
                                 .equ	PF2	= 2	; For compatibility
                                 .equ	PORTF3	= 3	; 
                                 .equ	PF3	= 3	; For compatibility
                                 .equ	PORTF4	= 4	; 
                                 .equ	PF4	= 4	; For compatibility
                                 .equ	PORTF5	= 5	; 
                                 .equ	PF5	= 5	; For compatibility
                                 .equ	PORTF6	= 6	; 
                                 .equ	PF6	= 6	; For compatibility
                                 .equ	PORTF7	= 7	; 
                                 .equ	PF7	= 7	; For compatibility
                                 
                                 ; DDRF - Data Direction Register, Port F
                                 .equ	DDF0	= 0	; 
                                 .equ	DDF1	= 1	; 
                                 .equ	DDF2	= 2	; 
                                 .equ	DDF3	= 3	; 
                                 .equ	DDF4	= 4	; 
                                 .equ	DDF5	= 5	; 
                                 .equ	DDF6	= 6	; 
                                 .equ	DDF7	= 7	; 
                                 
                                 ; PINF - Input Pins, Port F
                                 .equ	PINF0	= 0	; 
                                 .equ	PINF1	= 1	; 
                                 .equ	PINF2	= 2	; 
                                 .equ	PINF3	= 3	; 
                                 .equ	PINF4	= 4	; 
                                 .equ	PINF5	= 5	; 
                                 .equ	PINF6	= 6	; 
                                 .equ	PINF7	= 7	; 
                                 
                                 
                                 ; ***** PORTG ************************
                                 ; PORTG - Data Register, Port G
                                 .equ	PORTG0	= 0	; 
                                 .equ	PG0	= 0	; For compatibility
                                 .equ	PORTG1	= 1	; 
                                 .equ	PG1	= 1	; For compatibility
                                 .equ	PORTG2	= 2	; 
                                 .equ	PG2	= 2	; For compatibility
                                 .equ	PORTG3	= 3	; 
                                 .equ	PG3	= 3	; For compatibility
                                 .equ	PORTG4	= 4	; 
                                 .equ	PG4	= 4	; For compatibility
                                 .equ	PORTG5	= 5	; 
                                 .equ	PG5	= 5	; For compatibility
                                 
                                 ; DDRG - Data Direction Register, Port G
                                 .equ	DDG0	= 0	; 
                                 .equ	DDG1	= 1	; 
                                 .equ	DDG2	= 2	; 
                                 .equ	DDG3	= 3	; 
                                 .equ	DDG4	= 4	; 
                                 .equ	DDG5	= 5	; 
                                 
                                 ; PING - Input Pins, Port G
                                 .equ	PING0	= 0	; 
                                 .equ	PING1	= 1	; 
                                 .equ	PING2	= 2	; 
                                 .equ	PING3	= 3	; 
                                 .equ	PING4	= 4	; 
                                 .equ	PING5	= 5	; 
                                 
                                 
                                 ; ***** PORTH ************************
                                 ; PORTH - PORT H Data Register
                                 .equ	PORTH0	= 0	; PORT H Data Register bit 0
                                 .equ	PH0	= 0	; For compatibility
                                 .equ	PORTH1	= 1	; PORT H Data Register bit 1
                                 .equ	PH1	= 1	; For compatibility
                                 .equ	PORTH2	= 2	; PORT H Data Register bit 2
                                 .equ	PH2	= 2	; For compatibility
                                 .equ	PORTH3	= 3	; PORT H Data Register bit 3
                                 .equ	PH3	= 3	; For compatibility
                                 .equ	PORTH4	= 4	; PORT H Data Register bit 4
                                 .equ	PH4	= 4	; For compatibility
                                 .equ	PORTH5	= 5	; PORT H Data Register bit 5
                                 .equ	PH5	= 5	; For compatibility
                                 .equ	PORTH6	= 6	; PORT H Data Register bit 6
                                 .equ	PH6	= 6	; For compatibility
                                 .equ	PORTH7	= 7	; PORT H Data Register bit 7
                                 .equ	PH7	= 7	; For compatibility
                                 
                                 ; DDRH - PORT H Data Direction Register
                                 .equ	DDH0	= 0	; PORT H Data Direction Register bit 0
                                 .equ	DDH1	= 1	; PORT H Data Direction Register bit 1
                                 .equ	DDH2	= 2	; PORT H Data Direction Register bit 2
                                 .equ	DDH3	= 3	; PORT H Data Direction Register bit 3
                                 .equ	DDH4	= 4	; PORT H Data Direction Register bit 4
                                 .equ	DDH5	= 5	; PORT H Data Direction Register bit 5
                                 .equ	DDH6	= 6	; PORT H Data Direction Register bit 6
                                 .equ	DDH7	= 7	; PORT H Data Direction Register bit 7
                                 
                                 ; PINH - PORT H Input Pins
                                 .equ	PINH0	= 0	; PORT H Input Pins bit 0
                                 .equ	PINH1	= 1	; PORT H Input Pins bit 1
                                 .equ	PINH2	= 2	; PORT H Input Pins bit 2
                                 .equ	PINH3	= 3	; PORT H Input Pins bit 3
                                 .equ	PINH4	= 4	; PORT H Input Pins bit 4
                                 .equ	PINH5	= 5	; PORT H Input Pins bit 5
                                 .equ	PINH6	= 6	; PORT H Input Pins bit 6
                                 .equ	PINH7	= 7	; PORT H Input Pins bit 7
                                 
                                 
                                 ; ***** PORTJ ************************
                                 ; PORTJ - PORT J Data Register
                                 .equ	PORTJ0	= 0	; PORT J Data Register bit 0
                                 .equ	PJ0	= 0	; For compatibility
                                 .equ	PORTJ1	= 1	; PORT J Data Register bit 1
                                 .equ	PJ1	= 1	; For compatibility
                                 .equ	PORTJ2	= 2	; PORT J Data Register bit 2
                                 .equ	PJ2	= 2	; For compatibility
                                 .equ	PORTJ3	= 3	; PORT J Data Register bit 3
                                 .equ	PJ3	= 3	; For compatibility
                                 .equ	PORTJ4	= 4	; PORT J Data Register bit 4
                                 .equ	PJ4	= 4	; For compatibility
                                 .equ	PORTJ5	= 5	; PORT J Data Register bit 5
                                 .equ	PJ5	= 5	; For compatibility
                                 .equ	PORTJ6	= 6	; PORT J Data Register bit 6
                                 .equ	PJ6	= 6	; For compatibility
                                 .equ	PORTJ7	= 7	; PORT J Data Register bit 7
                                 .equ	PJ7	= 7	; For compatibility
                                 
                                 ; DDRJ - PORT J Data Direction Register
                                 .equ	DDJ0	= 0	; PORT J Data Direction Register bit 0
                                 .equ	DDJ1	= 1	; PORT J Data Direction Register bit 1
                                 .equ	DDJ2	= 2	; PORT J Data Direction Register bit 2
                                 .equ	DDJ3	= 3	; PORT J Data Direction Register bit 3
                                 .equ	DDJ4	= 4	; PORT J Data Direction Register bit 4
                                 .equ	DDJ5	= 5	; PORT J Data Direction Register bit 5
                                 .equ	DDJ6	= 6	; PORT J Data Direction Register bit 6
                                 .equ	DDJ7	= 7	; PORT J Data Direction Register bit 7
                                 
                                 ; PINJ - PORT J Input Pins
                                 .equ	PINJ0	= 0	; PORT J Input Pins bit 0
                                 .equ	PINJ1	= 1	; PORT J Input Pins bit 1
                                 .equ	PINJ2	= 2	; PORT J Input Pins bit 2
                                 .equ	PINJ3	= 3	; PORT J Input Pins bit 3
                                 .equ	PINJ4	= 4	; PORT J Input Pins bit 4
                                 .equ	PINJ5	= 5	; PORT J Input Pins bit 5
                                 .equ	PINJ6	= 6	; PORT J Input Pins bit 6
                                 .equ	PINJ7	= 7	; PORT J Input Pins bit 7
                                 
                                 
                                 ; ***** PORTK ************************
                                 ; PORTK - PORT K Data Register
                                 .equ	PORTK0	= 0	; PORT K Data Register bit 0
                                 .equ	PK0	= 0	; For compatibility
                                 .equ	PORTK1	= 1	; PORT K Data Register bit 1
                                 .equ	PK1	= 1	; For compatibility
                                 .equ	PORTK2	= 2	; PORT K Data Register bit 2
                                 .equ	PK2	= 2	; For compatibility
                                 .equ	PORTK3	= 3	; PORT K Data Register bit 3
                                 .equ	PK3	= 3	; For compatibility
                                 .equ	PORTK4	= 4	; PORT K Data Register bit 4
                                 .equ	PK4	= 4	; For compatibility
                                 .equ	PORTK5	= 5	; PORT K Data Register bit 5
                                 .equ	PK5	= 5	; For compatibility
                                 .equ	PORTK6	= 6	; PORT K Data Register bit 6
                                 .equ	PK6	= 6	; For compatibility
                                 .equ	PORTK7	= 7	; PORT K Data Register bit 7
                                 .equ	PK7	= 7	; For compatibility
                                 
                                 ; DDRK - PORT K Data Direction Register
                                 .equ	DDK0	= 0	; PORT K Data Direction Register bit 0
                                 .equ	DDK1	= 1	; PORT K Data Direction Register bit 1
                                 .equ	DDK2	= 2	; PORT K Data Direction Register bit 2
                                 .equ	DDK3	= 3	; PORT K Data Direction Register bit 3
                                 .equ	DDK4	= 4	; PORT K Data Direction Register bit 4
                                 .equ	DDK5	= 5	; PORT K Data Direction Register bit 5
                                 .equ	DDK6	= 6	; PORT K Data Direction Register bit 6
                                 .equ	DDK7	= 7	; PORT K Data Direction Register bit 7
                                 
                                 ; PINK - PORT K Input Pins
                                 .equ	PINK0	= 0	; PORT K Input Pins bit 0
                                 .equ	PINK1	= 1	; PORT K Input Pins bit 1
                                 .equ	PINK2	= 2	; PORT K Input Pins bit 2
                                 .equ	PINK3	= 3	; PORT K Input Pins bit 3
                                 .equ	PINK4	= 4	; PORT K Input Pins bit 4
                                 .equ	PINK5	= 5	; PORT K Input Pins bit 5
                                 .equ	PINK6	= 6	; PORT K Input Pins bit 6
                                 .equ	PINK7	= 7	; PORT K Input Pins bit 7
                                 
                                 
                                 ; ***** PORTL ************************
                                 ; PORTL - PORT L Data Register
                                 .equ	PORTL0	= 0	; PORT L Data Register bit 0
                                 .equ	PL0	= 0	; For compatibility
                                 .equ	PORTL1	= 1	; PORT L Data Register bit 1
                                 .equ	PL1	= 1	; For compatibility
                                 .equ	PORTL2	= 2	; PORT L Data Register bit 2
                                 .equ	PL2	= 2	; For compatibility
                                 .equ	PORTL3	= 3	; PORT L Data Register bit 3
                                 .equ	PL3	= 3	; For compatibility
                                 .equ	PORTL4	= 4	; PORT L Data Register bit 4
                                 .equ	PL4	= 4	; For compatibility
                                 .equ	PORTL5	= 5	; PORT L Data Register bit 5
                                 .equ	PL5	= 5	; For compatibility
                                 .equ	PORTL6	= 6	; PORT L Data Register bit 6
                                 .equ	PL6	= 6	; For compatibility
                                 .equ	PORTL7	= 7	; PORT L Data Register bit 7
                                 .equ	PL7	= 7	; For compatibility
                                 
                                 ; DDRL - PORT L Data Direction Register
                                 .equ	DDL0	= 0	; PORT L Data Direction Register bit 0
                                 .equ	DDL1	= 1	; PORT L Data Direction Register bit 1
                                 .equ	DDL2	= 2	; PORT L Data Direction Register bit 2
                                 .equ	DDL3	= 3	; PORT L Data Direction Register bit 3
                                 .equ	DDL4	= 4	; PORT L Data Direction Register bit 4
                                 .equ	DDL5	= 5	; PORT L Data Direction Register bit 5
                                 .equ	DDL6	= 6	; PORT L Data Direction Register bit 6
                                 .equ	DDL7	= 7	; PORT L Data Direction Register bit 7
                                 
                                 ; PINL - PORT L Input Pins
                                 .equ	PINL0	= 0	; PORT L Input Pins bit 0
                                 .equ	PINL1	= 1	; PORT L Input Pins bit 1
                                 .equ	PINL2	= 2	; PORT L Input Pins bit 2
                                 .equ	PINL3	= 3	; PORT L Input Pins bit 3
                                 .equ	PINL4	= 4	; PORT L Input Pins bit 4
                                 .equ	PINL5	= 5	; PORT L Input Pins bit 5
                                 .equ	PINL6	= 6	; PORT L Input Pins bit 6
                                 .equ	PINL7	= 7	; PORT L Input Pins bit 7
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TIMSK0 - Timer/Counter0 Interrupt Mask Register
                                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0A	= 1	; Timer/Counter0 Output Compare Match A Interrupt Enable
                                 .equ	OCIE0B	= 2	; Timer/Counter0 Output Compare Match B Interrupt Enable
                                 
                                 ; TIFR0 - Timer/Counter0 Interrupt Flag register
                                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0A	= 1	; Timer/Counter0 Output Compare Flag 0A
                                 .equ	OCF0B	= 2	; Timer/Counter0 Output Compare Flag 0B
                                 
                                 ; TCCR0A - Timer/Counter  Control Register A
                                 .equ	WGM00	= 0	; Waveform Generation Mode
                                 .equ	WGM01	= 1	; Waveform Generation Mode
                                 .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
                                 .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
                                 .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
                                 .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
                                 
                                 ; TCCR0B - Timer/Counter Control Register B
                                 .equ	CS00	= 0	; Clock Select
                                 .equ	CS01	= 1	; Clock Select
                                 .equ	CS02	= 2	; Clock Select
                                 .equ	WGM02	= 3	; 
                                 .equ	FOC0B	= 6	; Force Output Compare B
                                 .equ	FOC0A	= 7	; Force Output Compare A
                                 
                                 ; TCNT0 - Timer/Counter0
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0A - Timer/Counter0 Output Compare Register
                                 .equ	OCR0A_0	= 0	; 
                                 .equ	OCR0A_1	= 1	; 
                                 .equ	OCR0A_2	= 2	; 
                                 .equ	OCR0A_3	= 3	; 
                                 .equ	OCR0A_4	= 4	; 
                                 .equ	OCR0A_5	= 5	; 
                                 .equ	OCR0A_6	= 6	; 
                                 .equ	OCR0A_7	= 7	; 
                                 
                                 ; OCR0B - Timer/Counter0 Output Compare Register
                                 .equ	OCR0B_0	= 0	; 
                                 .equ	OCR0B_1	= 1	; 
                                 .equ	OCR0B_2	= 2	; 
                                 .equ	OCR0B_3	= 3	; 
                                 .equ	OCR0B_4	= 4	; 
                                 .equ	OCR0B_5	= 5	; 
                                 .equ	OCR0B_6	= 6	; 
                                 .equ	OCR0B_7	= 7	; 
                                 
                                 ; GTCCR - General Timer/Counter Control Register
                                 .equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                                 .equ	PSR10	= PSRSYNC	; For compatibility
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TIMSK2 - Timer/Counter Interrupt Mask register
                                 .equ	TOIE2	= 0	; Timer/Counter2 Overflow Interrupt Enable
                                 .equ	TOIE2A	= TOIE2	; For compatibility
                                 .equ	OCIE2A	= 1	; Timer/Counter2 Output Compare Match A Interrupt Enable
                                 .equ	OCIE2B	= 2	; Timer/Counter2 Output Compare Match B Interrupt Enable
                                 
                                 ; TIFR2 - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 0	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2A	= 1	; Output Compare Flag 2A
                                 .equ	OCF2B	= 2	; Output Compare Flag 2B
                                 
                                 ; TCCR2A - Timer/Counter2 Control Register A
                                 .equ	WGM20	= 0	; Waveform Genration Mode
                                 .equ	WGM21	= 1	; Waveform Genration Mode
                                 .equ	COM2B0	= 4	; Compare Output Mode bit 0
                                 .equ	COM2B1	= 5	; Compare Output Mode bit 1
                                 .equ	COM2A0	= 6	; Compare Output Mode bit 1
                                 .equ	COM2A1	= 7	; Compare Output Mode bit 1
                                 
                                 ; TCCR2B - Timer/Counter2 Control Register B
                                 .equ	CS20	= 0	; Clock Select bit 0
                                 .equ	CS21	= 1	; Clock Select bit 1
                                 .equ	CS22	= 2	; Clock Select bit 2
                                 .equ	WGM22	= 3	; Waveform Generation Mode
                                 .equ	FOC2B	= 6	; Force Output Compare B
                                 .equ	FOC2A	= 7	; Force Output Compare A
                                 
                                 ; TCNT2 - Timer/Counter2
                                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                                 
                                 ; OCR2A - Timer/Counter2 Output Compare Register A
                                 .equ	OCR2A_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                                 .equ	OCR2A_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                                 .equ	OCR2A_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                                 .equ	OCR2A_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                                 .equ	OCR2A_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                                 .equ	OCR2A_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                                 .equ	OCR2A_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                                 .equ	OCR2A_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                                 
                                 ; OCR2B - Timer/Counter2 Output Compare Register B
                                 .equ	OCR2B_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                                 .equ	OCR2B_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                                 .equ	OCR2B_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                                 .equ	OCR2B_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                                 .equ	OCR2B_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                                 .equ	OCR2B_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                                 .equ	OCR2B_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                                 .equ	OCR2B_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                                 
                                 ; ASSR - Asynchronous Status Register
                                 .equ	TCR2BUB	= 0	; Timer/Counter Control Register2 Update Busy
                                 .equ	TCR2AUB	= 1	; Timer/Counter Control Register2 Update Busy
                                 .equ	OCR2BUB	= 2	; Output Compare Register 2 Update Busy
                                 .equ	OCR2AUB	= 3	; Output Compare Register2 Update Busy
                                 .equ	TCN2UB	= 4	; Timer/Counter2 Update Busy
                                 .equ	AS2	= 5	; Asynchronous Timer/Counter2
                                 .equ	EXCLK	= 6	; Enable External Clock Input
                                 
                                 ; GTCCR - General Timer Counter Control register
                                 .equ	PSRASY	= 1	; Prescaler Reset Timer/Counter2
                                 .equ	PSR2	= PSRASY	; For compatibility
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCSR - Watchdog Timer Control Register
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                                 
                                 
                                 ; ***** USART1 ***********************
                                 ; UDR1 - USART I/O Data Register
                                 .equ	UDR1_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR1_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR1_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR1_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR1_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR1_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR1_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR1_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR1A - USART Control and Status Register A
                                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                                 .equ	U2X1	= 1	; Double the USART transmission speed
                                 .equ	UPE1	= 2	; Parity Error
                                 .equ	DOR1	= 3	; Data overRun
                                 .equ	FE1	= 4	; Framing Error
                                 .equ	UDRE1	= 5	; USART Data Register Empty
                                 .equ	TXC1	= 6	; USART Transmitt Complete
                                 .equ	RXC1	= 7	; USART Receive Complete
                                 
                                 ; UCSR1B - USART Control and Status Register B
                                 .equ	TXB81	= 0	; Transmit Data Bit 8
                                 .equ	RXB81	= 1	; Receive Data Bit 8
                                 .equ	UCSZ12	= 2	; Character Size
                                 .equ	TXEN1	= 3	; Transmitter Enable
                                 .equ	RXEN1	= 4	; Receiver Enable
                                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR1C - USART Control and Status Register C
                                 .equ	UCPOL1	= 0	; Clock Polarity
                                 .equ	UCSZ10	= 1	; Character Size
                                 .equ	UCPHA1	= UCSZ10	; For compatibility
                                 .equ	UCSZ11	= 2	; Character Size
                                 .equ	UDORD1	= UCSZ11	; For compatibility
                                 .equ	USBS1	= 3	; Stop Bit Select
                                 .equ	UPM10	= 4	; Parity Mode Bit 0
                                 .equ	UPM11	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL10	= 6	; USART Mode Select
                                 .equ	UMSEL11	= 7	; USART Mode Select
                                 
                                 ; UBRR1H - USART Baud Rate Register High Byte
                                 .equ	UBRR_8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR_9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR_10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR_11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR1L - USART Baud Rate Register Low Byte
                                 .equ	UBRR_0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR_1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR_2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR_3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR_4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR_5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR_6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR_7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEARH - EEPROM Address Register Low Byte
                                 .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 8
                                 .equ	EEAR9	= 1	; EEPROM Read/Write Access Bit 9
                                 .equ	EEAR10	= 2	; EEPROM Read/Write Access Bit 10
                                 .equ	EEAR11	= 3	; EEPROM Read/Write Access Bit 11
                                 
                                 ; EEARL - EEPROM Address Register Low Byte
                                 .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                                 .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                                 .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                                 .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                                 .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                                 .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                                 .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                                 .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                                 
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEPE	= 1	; EEPROM Write Enable
                                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                                 .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                                 
                                 
                                 ; ***** TIMER_COUNTER_5 **************
                                 ; TIMSK5 - Timer/Counter5 Interrupt Mask Register
                                 .equ	TOIE5	= 0	; Timer/Counter5 Overflow Interrupt Enable
                                 .equ	OCIE5A	= 1	; Timer/Counter5 Output Compare A Match Interrupt Enable
                                 .equ	OCIE5B	= 2	; Timer/Counter5 Output Compare B Match Interrupt Enable
                                 .equ	OCIE5C	= 3	; Timer/Counter5 Output Compare C Match Interrupt Enable
                                 .equ	ICIE5	= 5	; Timer/Counter5 Input Capture Interrupt Enable
                                 
                                 ; TIFR5 - Timer/Counter5 Interrupt Flag register
                                 .equ	TOV5	= 0	; Timer/Counter5 Overflow Flag
                                 .equ	OCF5A	= 1	; Output Compare Flag 5A
                                 .equ	OCF5B	= 2	; Output Compare Flag 5B
                                 .equ	OCF5C	= 3	; Output Compare Flag 5C
                                 .equ	ICF5	= 5	; Input Capture Flag 5
                                 
                                 ; TCCR5A - Timer/Counter5 Control Register A
                                 .equ	WGM50	= 0	; Waveform Generation Mode
                                 .equ	WGM51	= 1	; Waveform Generation Mode
                                 .equ	COM5C0	= 2	; Compare Output Mode 5C, bit 0
                                 .equ	COM5C1	= 3	; Compare Output Mode 5C, bit 1
                                 .equ	COM5B0	= 4	; Compare Output Mode 5B, bit 0
                                 .equ	COM5B1	= 5	; Compare Output Mode 5B, bit 1
                                 .equ	COM5A0	= 6	; Compare Output Mode 5A, bit 0
                                 .equ	COM5A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR5B - Timer/Counter5 Control Register B
                                 .equ	CS50	= 0	; Prescaler source of Timer/Counter 5
                                 .equ	CS51	= 1	; Prescaler source of Timer/Counter 5
                                 .equ	CS52	= 2	; Prescaler source of Timer/Counter 5
                                 .equ	WGM52	= 3	; Waveform Generation Mode
                                 .equ	WGM53	= 4	; Waveform Generation Mode
                                 .equ	ICES5	= 6	; Input Capture 5 Edge Select
                                 .equ	ICNC5	= 7	; Input Capture 5 Noise Canceler
                                 
                                 ; TCCR5C - Timer/Counter 5 Control Register C
                                 .equ	FOC5C	= 5	; Force Output Compare 5C
                                 .equ	FOC5B	= 6	; Force Output Compare 5B
                                 .equ	FOC5A	= 7	; Force Output Compare 5A
                                 
                                 ; ICR5H - Timer/Counter5 Input Capture Register High Byte
                                 .equ	ICR5H0	= 0	; Timer/Counter5 Input Capture Register High Byte bit 0
                                 .equ	ICR5H1	= 1	; Timer/Counter5 Input Capture Register High Byte bit 1
                                 .equ	ICR5H2	= 2	; Timer/Counter5 Input Capture Register High Byte bit 2
                                 .equ	ICR5H3	= 3	; Timer/Counter5 Input Capture Register High Byte bit 3
                                 .equ	ICR5H4	= 4	; Timer/Counter5 Input Capture Register High Byte bit 4
                                 .equ	ICR5H5	= 5	; Timer/Counter5 Input Capture Register High Byte bit 5
                                 .equ	ICR5H6	= 6	; Timer/Counter5 Input Capture Register High Byte bit 6
                                 .equ	ICR5H7	= 7	; Timer/Counter5 Input Capture Register High Byte bit 7
                                 
                                 ; ICR5L - Timer/Counter5 Input Capture Register Low Byte
                                 .equ	ICR5L0	= 0	; Timer/Counter5 Input Capture Register Low Byte bit 0
                                 .equ	ICR5L1	= 1	; Timer/Counter5 Input Capture Register Low Byte bit 1
                                 .equ	ICR5L2	= 2	; Timer/Counter5 Input Capture Register Low Byte bit 2
                                 .equ	ICR5L3	= 3	; Timer/Counter5 Input Capture Register Low Byte bit 3
                                 .equ	ICR5L4	= 4	; Timer/Counter5 Input Capture Register Low Byte bit 4
                                 .equ	ICR5L5	= 5	; Timer/Counter5 Input Capture Register Low Byte bit 5
                                 .equ	ICR5L6	= 6	; Timer/Counter5 Input Capture Register Low Byte bit 6
                                 .equ	ICR5L7	= 7	; Timer/Counter5 Input Capture Register Low Byte bit 7
                                 
                                 
                                 ; ***** TIMER_COUNTER_4 **************
                                 ; TIMSK4 - Timer/Counter4 Interrupt Mask Register
                                 .equ	TOIE4	= 0	; Timer/Counter4 Overflow Interrupt Enable
                                 .equ	OCIE4A	= 1	; Timer/Counter4 Output Compare A Match Interrupt Enable
                                 .equ	OCIE4B	= 2	; Timer/Counter4 Output Compare B Match Interrupt Enable
                                 .equ	OCIE4C	= 3	; Timer/Counter4 Output Compare C Match Interrupt Enable
                                 .equ	ICIE4	= 5	; Timer/Counter4 Input Capture Interrupt Enable
                                 
                                 ; TIFR4 - Timer/Counter4 Interrupt Flag register
                                 .equ	TOV4	= 0	; Timer/Counter4 Overflow Flag
                                 .equ	OCF4A	= 1	; Output Compare Flag 4A
                                 .equ	OCF4B	= 2	; Output Compare Flag 4B
                                 .equ	OCF4C	= 3	; Output Compare Flag 4C
                                 .equ	ICF4	= 5	; Input Capture Flag 4
                                 
                                 ; TCCR4A - Timer/Counter4 Control Register A
                                 .equ	WGM40	= 0	; Waveform Generation Mode
                                 .equ	WGM41	= 1	; Waveform Generation Mode
                                 .equ	COM4C0	= 2	; Compare Output Mode 4C, bit 0
                                 .equ	COM4C1	= 3	; Compare Output Mode 4C, bit 1
                                 .equ	COM4B0	= 4	; Compare Output Mode 4B, bit 0
                                 .equ	COM4B1	= 5	; Compare Output Mode 4B, bit 1
                                 .equ	COM4A0	= 6	; Compare Output Mode 4A, bit 0
                                 .equ	COM4A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR4B - Timer/Counter4 Control Register B
                                 .equ	CS40	= 0	; Prescaler source of Timer/Counter 4
                                 .equ	CS41	= 1	; Prescaler source of Timer/Counter 4
                                 .equ	CS42	= 2	; Prescaler source of Timer/Counter 4
                                 .equ	WGM42	= 3	; Waveform Generation Mode
                                 .equ	WGM43	= 4	; Waveform Generation Mode
                                 .equ	ICES4	= 6	; Input Capture 4 Edge Select
                                 .equ	ICNC4	= 7	; Input Capture 4 Noise Canceler
                                 
                                 ; TCCR4C - Timer/Counter 4 Control Register C
                                 .equ	FOC4C	= 5	; Force Output Compare 4C
                                 .equ	FOC4B	= 6	; Force Output Compare 4B
                                 .equ	FOC4A	= 7	; Force Output Compare 4A
                                 
                                 
                                 ; ***** TIMER_COUNTER_3 **************
                                 ; TIMSK3 - Timer/Counter3 Interrupt Mask Register
                                 .equ	TOIE3	= 0	; Timer/Counter3 Overflow Interrupt Enable
                                 .equ	OCIE3A	= 1	; Timer/Counter3 Output Compare A Match Interrupt Enable
                                 .equ	OCIE3B	= 2	; Timer/Counter3 Output Compare B Match Interrupt Enable
                                 .equ	OCIE3C	= 3	; Timer/Counter3 Output Compare C Match Interrupt Enable
                                 .equ	ICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                                 
                                 ; TIFR3 - Timer/Counter3 Interrupt Flag register
                                 .equ	TOV3	= 0	; Timer/Counter3 Overflow Flag
                                 .equ	OCF3A	= 1	; Output Compare Flag 3A
                                 .equ	OCF3B	= 2	; Output Compare Flag 3B
                                 .equ	OCF3C	= 3	; Output Compare Flag 3C
                                 .equ	ICF3	= 5	; Input Capture Flag 3
                                 
                                 ; TCCR3A - Timer/Counter3 Control Register A
                                 .equ	WGM30	= 0	; Waveform Generation Mode
                                 .equ	WGM31	= 1	; Waveform Generation Mode
                                 .equ	COM3C0	= 2	; Compare Output Mode 3C, bit 0
                                 .equ	COM3C1	= 3	; Compare Output Mode 3C, bit 1
                                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                                 .equ	COM3A0	= 6	; Compare Output Mode 3A, bit 0
                                 .equ	COM3A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR3B - Timer/Counter3 Control Register B
                                 .equ	CS30	= 0	; Prescaler source of Timer/Counter 3
                                 .equ	CS31	= 1	; Prescaler source of Timer/Counter 3
                                 .equ	CS32	= 2	; Prescaler source of Timer/Counter 3
                                 .equ	WGM32	= 3	; Waveform Generation Mode
                                 .equ	WGM33	= 4	; Waveform Generation Mode
                                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                                 .equ	ICNC3	= 7	; Input Capture 3 Noise Canceler
                                 
                                 ; TCCR3C - Timer/Counter 3 Control Register C
                                 .equ	FOC3C	= 5	; Force Output Compare 3C
                                 .equ	FOC3B	= 6	; Force Output Compare 3B
                                 .equ	FOC3A	= 7	; Force Output Compare 3A
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK1 - Timer/Counter1 Interrupt Mask Register
                                 .equ	TOIE1	= 0	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1A	= 1	; Timer/Counter1 Output Compare A Match Interrupt Enable
                                 .equ	OCIE1B	= 2	; Timer/Counter1 Output Compare B Match Interrupt Enable
                                 .equ	OCIE1C	= 3	; Timer/Counter1 Output Compare C Match Interrupt Enable
                                 .equ	ICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; TIFR1 - Timer/Counter1 Interrupt Flag register
                                 .equ	TOV1	= 0	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1A	= 1	; Output Compare Flag 1A
                                 .equ	OCF1B	= 2	; Output Compare Flag 1B
                                 .equ	OCF1C	= 3	; Output Compare Flag 1C
                                 .equ	ICF1	= 5	; Input Capture Flag 1
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Waveform Generation Mode
                                 .equ	WGM11	= 1	; Waveform Generation Mode
                                 .equ	COM1C0	= 2	; Compare Output Mode 1C, bit 0
                                 .equ	COM1C1	= 3	; Compare Output Mode 1C, bit 1
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Compare Output Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                                 .equ	WGM12	= 3	; Waveform Generation Mode
                                 .equ	WGM13	= 4	; Waveform Generation Mode
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 ; TCCR1C - Timer/Counter 1 Control Register C
                                 .equ	FOC1C	= 5	; Force Output Compare 1C
                                 .equ	FOC1B	= 6	; Force Output Compare 1B
                                 .equ	FOC1A	= 7	; Force Output Compare 1A
                                 
                                 
                                 ; ***** JTAG *************************
                                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                                 .equ	IDRD	= OCDR7	; For compatibility
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; MCUSR - MCU Status Register
                                 .equ	JTRF	= 4	; JTAG Reset Flag
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register A
                                 .equ	ISC00	= 0	; External Interrupt Sense Control Bit
                                 .equ	ISC01	= 1	; External Interrupt Sense Control Bit
                                 .equ	ISC10	= 2	; External Interrupt Sense Control Bit
                                 .equ	ISC11	= 3	; External Interrupt Sense Control Bit
                                 .equ	ISC20	= 4	; External Interrupt Sense Control Bit
                                 .equ	ISC21	= 5	; External Interrupt Sense Control Bit
                                 .equ	ISC30	= 6	; External Interrupt Sense Control Bit
                                 .equ	ISC31	= 7	; External Interrupt Sense Control Bit
                                 
                                 ; EICRB - External Interrupt Control Register B
                                 .equ	ISC40	= 0	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC41	= 1	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC50	= 2	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC51	= 3	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC60	= 4	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC61	= 5	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC70	= 6	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC71	= 7	; External Interrupt 7-4 Sense Control Bit
                                 
                                 ; EIMSK - External Interrupt Mask Register
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                                 .equ	INT2	= 2	; External Interrupt Request 2 Enable
                                 .equ	INT3	= 3	; External Interrupt Request 3 Enable
                                 .equ	INT4	= 4	; External Interrupt Request 4 Enable
                                 .equ	INT5	= 5	; External Interrupt Request 5 Enable
                                 .equ	INT6	= 6	; External Interrupt Request 6 Enable
                                 .equ	INT7	= 7	; External Interrupt Request 7 Enable
                                 
                                 ; EIFR - External Interrupt Flag Register
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 .equ	INTF1	= 1	; External Interrupt Flag 1
                                 .equ	INTF2	= 2	; External Interrupt Flag 2
                                 .equ	INTF3	= 3	; External Interrupt Flag 3
                                 .equ	INTF4	= 4	; External Interrupt Flag 4
                                 .equ	INTF5	= 5	; External Interrupt Flag 5
                                 .equ	INTF6	= 6	; External Interrupt Flag 6
                                 .equ	INTF7	= 7	; External Interrupt Flag 7
                                 
                                 ; PCICR - Pin Change Interrupt Control Register
                                 .equ	PCIE0	= 0	; Pin Change Interrupt Enable 0
                                 .equ	PCIE1	= 1	; Pin Change Interrupt Enable 1
                                 .equ	PCIE2	= 2	; Pin Change Interrupt Enable 2
                                 
                                 ; PCIFR - Pin Change Interrupt Flag Register
                                 .equ	PCIF0	= 0	; Pin Change Interrupt Flag 0
                                 .equ	PCIF1	= 1	; Pin Change Interrupt Flag 1
                                 .equ	PCIF2	= 2	; Pin Change Interrupt Flag 2
                                 
                                 ; PCMSK2 - Pin Change Mask Register 2
                                 .equ	PCINT16	= 0	; Pin Change Enable Mask 16
                                 .equ	PCINT17	= 1	; Pin Change Enable Mask 17
                                 .equ	PCINT18	= 2	; Pin Change Enable Mask 18
                                 .equ	PCINT19	= 3	; Pin Change Enable Mask 19
                                 .equ	PCINT20	= 4	; Pin Change Enable Mask 20
                                 .equ	PCINT21	= 5	; Pin Change Enable Mask 21
                                 .equ	PCINT22	= 6	; Pin Change Enable Mask 22
                                 .equ	PCINT23	= 7	; Pin Change Enable Mask 23
                                 
                                 ; PCMSK1 - Pin Change Mask Register 1
                                 .equ	PCINT8	= 0	; Pin Change Enable Mask 8
                                 .equ	PCINT9	= 1	; Pin Change Enable Mask 9
                                 .equ	PCINT10	= 2	; Pin Change Enable Mask 10
                                 .equ	PCINT11	= 3	; Pin Change Enable Mask 11
                                 .equ	PCINT12	= 4	; Pin Change Enable Mask 12
                                 .equ	PCINT13	= 5	; Pin Change Enable Mask 13
                                 .equ	PCINT14	= 6	; Pin Change Enable Mask 14
                                 .equ	PCINT15	= 7	; Pin Change Enable Mask 15
                                 
                                 ; PCMSK0 - Pin Change Mask Register 0
                                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                                 .equ	PCINT4	= 4	; Pin Change Enable Mask 4
                                 .equ	PCINT5	= 5	; Pin Change Enable Mask 5
                                 .equ	PCINT6	= 6	; Pin Change Enable Mask 6
                                 .equ	PCINT7	= 7	; Pin Change Enable Mask 7
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                                 .equ	IVSEL	= 1	; Interrupt Vector Select
                                 .equ	PUD	= 4	; Pull-up disable
                                 ;.equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; MCUSR - MCU Status Register
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                                 
                                 ; XMCRA - External Memory Control Register A
                                 .equ	SRW00	= 0	; Wait state select bit lower page
                                 .equ	SRW01	= 1	; Wait state select bit lower page
                                 .equ	SRW10	= 2	; Wait state select bit upper page
                                 .equ	SRW11	= 3	; Wait state select bit upper page
                                 .equ	SRL0	= 4	; Wait state page limit
                                 .equ	SRL1	= 5	; Wait state page limit
                                 .equ	SRL2	= 6	; Wait state page limit
                                 .equ	SRE	= 7	; External SRAM Enable
                                 
                                 ; XMCRB - External Memory Control Register B
                                 .equ	XMM0	= 0	; External Memory High Mask
                                 .equ	XMM1	= 1	; External Memory High Mask
                                 .equ	XMM2	= 2	; External Memory High Mask
                                 .equ	XMBK	= 7	; External Memory Bus Keeper Enable
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                                 
                                 ; CLKPR - 
                                 .equ	CLKPS0	= 0	; 
                                 .equ	CLKPS1	= 1	; 
                                 .equ	CLKPS2	= 2	; 
                                 .equ	CLKPS3	= 3	; 
                                 .equ	CLKPCE	= 7	; 
                                 
                                 ; SMCR - Sleep Mode Control Register
                                 .equ	SE	= 0	; Sleep Enable
                                 .equ	SM0	= 1	; Sleep Mode Select bit 0
                                 .equ	SM1	= 2	; Sleep Mode Select bit 1
                                 .equ	SM2	= 3	; Sleep Mode Select bit 2
                                 
                                 ; RAMPZ - RAM Page Z Select Register
                                 .equ	RAMPZ0	= 0	; RAM Page Z Select Register Bit 0
                                 .equ	RAMPZ1	= 1	; RAM Page Z Select Register Bit 1
                                 
                                 ; EIND - Extended Indirect Register
                                 .equ	EIND0	= 0	; Bit 0
                                 
                                 ; GPIOR2 - General Purpose IO Register 2
                                 .equ	GPIOR20	= 0	; General Purpose IO Register 2 bit 0
                                 .equ	GPIOR21	= 1	; General Purpose IO Register 2 bit 1
                                 .equ	GPIOR22	= 2	; General Purpose IO Register 2 bit 2
                                 .equ	GPIOR23	= 3	; General Purpose IO Register 2 bit 3
                                 .equ	GPIOR24	= 4	; General Purpose IO Register 2 bit 4
                                 .equ	GPIOR25	= 5	; General Purpose IO Register 2 bit 5
                                 .equ	GPIOR26	= 6	; General Purpose IO Register 2 bit 6
                                 .equ	GPIOR27	= 7	; General Purpose IO Register 2 bit 7
                                 
                                 ; GPIOR1 - General Purpose IO Register 1
                                 .equ	GPIOR10	= 0	; General Purpose IO Register 1 bit 0
                                 .equ	GPIOR11	= 1	; General Purpose IO Register 1 bit 1
                                 .equ	GPIOR12	= 2	; General Purpose IO Register 1 bit 2
                                 .equ	GPIOR13	= 3	; General Purpose IO Register 1 bit 3
                                 .equ	GPIOR14	= 4	; General Purpose IO Register 1 bit 4
                                 .equ	GPIOR15	= 5	; General Purpose IO Register 1 bit 5
                                 .equ	GPIOR16	= 6	; General Purpose IO Register 1 bit 6
                                 .equ	GPIOR17	= 7	; General Purpose IO Register 1 bit 7
                                 
                                 ; GPIOR0 - General Purpose IO Register 0
                                 .equ	GPIOR00	= 0	; General Purpose IO Register 0 bit 0
                                 .equ	GPIOR01	= 1	; General Purpose IO Register 0 bit 1
                                 .equ	GPIOR02	= 2	; General Purpose IO Register 0 bit 2
                                 .equ	GPIOR03	= 3	; General Purpose IO Register 0 bit 3
                                 .equ	GPIOR04	= 4	; General Purpose IO Register 0 bit 4
                                 .equ	GPIOR05	= 5	; General Purpose IO Register 0 bit 5
                                 .equ	GPIOR06	= 6	; General Purpose IO Register 0 bit 6
                                 .equ	GPIOR07	= 7	; General Purpose IO Register 0 bit 7
                                 
                                 ; PRR1 - Power Reduction Register1
                                 .equ	PRUSART1	= 0	; Power Reduction USART1
                                 .equ	PRUSART2	= 1	; Power Reduction USART2
                                 .equ	PRUSART3	= 2	; Power Reduction USART3
                                 .equ	PRTIM3	= 3	; Power Reduction Timer/Counter3
                                 .equ	PRTIM4	= 4	; Power Reduction Timer/Counter4
                                 .equ	PRTIM5	= 5	; Power Reduction Timer/Counter5
                                 
                                 ; PRR0 - Power Reduction Register0
                                 .equ	PRADC	= 0	; Power Reduction ADC
                                 .equ	PRUSART0	= 1	; Power Reduction USART
                                 .equ	PRSPI	= 2	; Power Reduction Serial Peripheral Interface
                                 .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                                 .equ	PRTIM0	= 5	; Power Reduction Timer/Counter0
                                 .equ	PRTIM2	= 6	; Power Reduction Timer/Counter2
                                 .equ	PRTWI	= 7	; Power Reduction TWI
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register A
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADATE	= 5	; ADC  Auto Trigger Enable
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCSRB - The ADC Control and Status register B
                                 .equ	ADTS0	= 0	; ADC Auto Trigger Source bit 0
                                 .equ	ADTS1	= 1	; ADC Auto Trigger Source bit 1
                                 .equ	ADTS2	= 2	; ADC Auto Trigger Source bit 2
                                 .equ	MUX5	= 3	; Analog Channel and Gain Selection Bits
                                 ;.equ	ACME	= 6	; 
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 ; DIDR0 - Digital Input Disable Register
                                 .equ	ADC0D	= 0	; 
                                 .equ	ADC1D	= 1	; 
                                 .equ	ADC2D	= 2	; 
                                 .equ	ADC3D	= 3	; 
                                 .equ	ADC4D	= 4	; 
                                 .equ	ADC5D	= 5	; 
                                 .equ	ADC6D	= 6	; 
                                 .equ	ADC7D	= 7	; 
                                 
                                 ; DIDR2 - Digital Input Disable Register
                                 .equ	ADC8D	= 0	; 
                                 .equ	ADC9D	= 1	; 
                                 .equ	ADC10D	= 2	; 
                                 .equ	ADC11D	= 3	; 
                                 .equ	ADC12D	= 4	; 
                                 .equ	ADC13D	= 5	; 
                                 .equ	ADC14D	= 6	; 
                                 .equ	ADC15D	= 7	; 
                                 
                                 
                                 ; ***** BOOT_LOAD ********************
                                 ; SPMCSR - Store Program Memory Control Register
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read While Write section read enable
                                 .equ	SIGRD	= 5	; Signature Row Read
                                 .equ	RWWSB	= 6	; Read While Write Section Busy
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 
                                 ; ***** USART2 ***********************
                                 ; UDR2 - USART I/O Data Register
                                 .equ	UDR2_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR2_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR2_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR2_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR2_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR2_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR2_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR2_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR2A - USART Control and Status Register A
                                 .equ	MPCM2	= 0	; Multi-processor Communication Mode
                                 .equ	U2X2	= 1	; Double the USART transmission speed
                                 .equ	UPE2	= 2	; Parity Error
                                 .equ	DOR2	= 3	; Data overRun
                                 .equ	FE2	= 4	; Framing Error
                                 .equ	UDRE2	= 5	; USART Data Register Empty
                                 .equ	TXC2	= 6	; USART Transmitt Complete
                                 .equ	RXC2	= 7	; USART Receive Complete
                                 
                                 ; UCSR2B - USART Control and Status Register B
                                 .equ	TXB82	= 0	; Transmit Data Bit 8
                                 .equ	RXB82	= 1	; Receive Data Bit 8
                                 .equ	UCSZ22	= 2	; Character Size
                                 .equ	TXEN2	= 3	; Transmitter Enable
                                 .equ	RXEN2	= 4	; Receiver Enable
                                 .equ	UDRIE2	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE2	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE2	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR2C - USART Control and Status Register C
                                 .equ	UCPOL2	= 0	; Clock Polarity
                                 .equ	UCSZ20	= 1	; Character Size
                                 .equ	UCSZ21	= 2	; Character Size
                                 .equ	USBS2	= 3	; Stop Bit Select
                                 .equ	UPM20	= 4	; Parity Mode Bit 0
                                 .equ	UPM21	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL20	= 6	; USART Mode Select
                                 .equ	UMSEL21	= 7	; USART Mode Select
                                 
                                 ; UBRR2H - USART Baud Rate Register High Byte
                                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR2L - USART Baud Rate Register Low Byte
                                 .equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** USART3 ***********************
                                 ; UDR3 - USART I/O Data Register
                                 .equ	UDR3_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR3_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR3_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR3_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR3_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR3_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR3_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR3_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR3A - USART Control and Status Register A
                                 .equ	MPCM3	= 0	; Multi-processor Communication Mode
                                 .equ	U2X3	= 1	; Double the USART transmission speed
                                 .equ	UPE3	= 2	; Parity Error
                                 .equ	DOR3	= 3	; Data overRun
                                 .equ	FE3	= 4	; Framing Error
                                 .equ	UDRE3	= 5	; USART Data Register Empty
                                 .equ	TXC3	= 6	; USART Transmitt Complete
                                 .equ	RXC3	= 7	; USART Receive Complete
                                 
                                 ; UCSR3B - USART Control and Status Register B
                                 .equ	TXB83	= 0	; Transmit Data Bit 8
                                 .equ	RXB83	= 1	; Receive Data Bit 8
                                 .equ	UCSZ32	= 2	; Character Size
                                 .equ	TXEN3	= 3	; Transmitter Enable
                                 .equ	RXEN3	= 4	; Receiver Enable
                                 .equ	UDRIE3	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE3	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE3	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR3C - USART Control and Status Register C
                                 .equ	UCPOL3	= 0	; Clock Polarity
                                 .equ	UCSZ30	= 1	; Character Size
                                 .equ	UCSZ31	= 2	; Character Size
                                 .equ	USBS3	= 3	; Stop Bit Select
                                 .equ	UPM30	= 4	; Parity Mode Bit 0
                                 .equ	UPM31	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL30	= 6	; USART Mode Select
                                 .equ	UMSEL31	= 7	; USART Mode Select
                                 
                                 ; UBRR3H - USART Baud Rate Register High Byte
                                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR3L - USART Baud Rate Register Low Byte
                                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 ;.equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	CKOUT	= 6	; Clock output
                                 .equ	CKDIV8	= 7	; Divide clock by 8
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select Reset Vector
                                 .equ	BOOTSZ0	= 1	; Select Boot Size
                                 .equ	BOOTSZ1	= 2	; Select Boot Size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	WDTON	= 4	; Watchdog timer always on
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	JTAGEN	= 6	; Enable JTAG
                                 .equ	OCDEN	= 7	; Enable OCD
                                 
                                 ; EXTENDED fuse bits
                                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0x1ffff	; Note: Word address
                                 .equ	IOEND	= 0x01ff
                                 .equ	SRAM_START	= 0x0200
                                 .equ	SRAM_SIZE	= 8192
                                 .equ	RAMEND	= 0x21ff
                                 .equ	XRAMEND	= 0xffff
                                 .equ	E2END	= 0x0fff
                                 .equ	EEPROMEND	= 0x0fff
                                 .equ	EEADRBITS	= 12
                                 #pragma AVRPART MEMORY PROG_FLASH 262144
                                 #pragma AVRPART MEMORY EEPROM 4096
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 8192
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x200
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0x1f000
                                 .equ	NRWW_STOP_ADDR	= 0x1ffff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0x1efff
                                 .equ	PAGESIZE	= 128
                                 .equ	FIRSTBOOTSTART	= 0x1fe00
                                 .equ	SECONDBOOTSTART	= 0x1fc00
                                 .equ	THIRDBOOTSTART	= 0x1f800
                                 .equ	FOURTHBOOTSTART	= 0x1f000
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                                 .equ	INT3addr	= 0x0008	; External Interrupt Request 3
                                 .equ	INT4addr	= 0x000a	; External Interrupt Request 4
                                 .equ	INT5addr	= 0x000c	; External Interrupt Request 5
                                 .equ	INT6addr	= 0x000e	; External Interrupt Request 6
                                 .equ	INT7addr	= 0x0010	; External Interrupt Request 7
                                 .equ	PCI0addr	= 0x0012	; Pin Change Interrupt Request 0
                                 .equ	PCI1addr	= 0x0014	; Pin Change Interrupt Request 1
                                 .equ	PCI2addr	= 0x0016	; Pin Change Interrupt Request 2
                                 .equ	WDTaddr	= 0x0018	; Watchdog Time-out Interrupt
                                 .equ	OC2Aaddr	= 0x001a	; Timer/Counter2 Compare Match A
                                 .equ	OC2Baddr	= 0x001c	; Timer/Counter2 Compare Match B
                                 .equ	OVF2addr	= 0x001e	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x0020	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0022	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x0024	; Timer/Counter1 Compare Match B
                                 .equ	OC1Caddr	= 0x0026	; Timer/Counter1 Compare Match C
                                 .equ	OVF1addr	= 0x0028	; Timer/Counter1 Overflow
                                 .equ	OC0Aaddr	= 0x002a	; Timer/Counter0 Compare Match A
                                 .equ	OC0Baddr	= 0x002c	; Timer/Counter0 Compare Match B
                                 .equ	OVF0addr	= 0x002e	; Timer/Counter0 Overflow
                                 .equ	SPIaddr	= 0x0030	; SPI Serial Transfer Complete
                                 .equ	URXC0addr	= 0x0032	; USART0, Rx Complete
                                 .equ	UDRE0addr	= 0x0034	; USART0 Data register Empty
                                 .equ	UTXC0addr	= 0x0036	; USART0, Tx Complete
                                 .equ	ACIaddr	= 0x0038	; Analog Comparator
                                 .equ	ADCCaddr	= 0x003a	; ADC Conversion Complete
                                 .equ	ERDYaddr	= 0x003c	; EEPROM Ready
                                 .equ	ICP3addr	= 0x003e	; Timer/Counter3 Capture Event
                                 .equ	OC3Aaddr	= 0x0040	; Timer/Counter3 Compare Match A
                                 .equ	OC3Baddr	= 0x0042	; Timer/Counter3 Compare Match B
                                 .equ	OC3Caddr	= 0x0044	; Timer/Counter3 Compare Match C
                                 .equ	OVF3addr	= 0x0046	; Timer/Counter3 Overflow
                                 .equ	URXC1addr	= 0x0048	; USART1, Rx Complete
                                 .equ	UDRE1addr	= 0x004a	; USART1 Data register Empty
                                 .equ	UTXC1addr	= 0x004c	; USART1, Tx Complete
                                 .equ	TWIaddr	= 0x004e	; 2-wire Serial Interface
                                 .equ	SPMRaddr	= 0x0050	; Store Program Memory Read
                                 .equ	ICP4addr	= 0x0052	; Timer/Counter4 Capture Event
                                 .equ	OC4Aaddr	= 0x0054	; Timer/Counter4 Compare Match A
                                 .equ	OC4Baddr	= 0x0056	; Timer/Counter4 Compare Match B
                                 .equ	OC4Caddr	= 0x0058	; Timer/Counter4 Compare Match C
                                 .equ	OVF4addr	= 0x005a	; Timer/Counter4 Overflow
                                 .equ	ICP5addr	= 0x005c	; Timer/Counter5 Capture Event
                                 .equ	OC5Aaddr	= 0x005e	; Timer/Counter5 Compare Match A
                                 .equ	OC5Baddr	= 0x0060	; Timer/Counter5 Compare Match B
                                 .equ	OC5Caddr	= 0x0062	; Timer/Counter5 Compare Match C
                                 .equ	OVF5addr	= 0x0064	; Timer/Counter5 Overflow
                                 .equ	URXC2addr	= 0x0066	; USART2, Rx Complete
                                 .equ	UDRE2addr	= 0x0068	; USART2 Data register Empty
                                 .equ	UTXC2addr	= 0x006a	; USART2, Tx Complete
                                 .equ	URXC3addr	= 0x006c	; USART3, Rx Complete
                                 .equ	UDRE3addr	= 0x006e	; USART3 Data register Empty
                                 .equ	UTXC3addr	= 0x0070	; USART3, Tx Complete
                                 
                                 .equ	INT_VECTORS_SIZE	= 114	; size in words
                                 
                                 #endif  /* _M2560DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ; pro2.asm
                                 ;
                                 ; Created: 30/05/2017 10:16:41 PM
                                 ; Author : asafp
                                 ;
                                 
                                 .include "m2560def.inc"
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega2560.xml **********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m2560def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega2560
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega2560
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M2560DEF_INC_
                                 #endif  /* _M2560DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 
                                 .def temp = r16
                                 .def temp1 = r17
                                 .def temp2 = r18
                                 
                                 //KEYPAD REGISTERS
                                 .def row = r19 ; current row number
                                 .def col = r20 ; current column number
                                 .def rmask = r21 ; mask for current row during scan
                                 .def cmask = r22 ; mask for current column during scan
                                 
                                 
                                 //KEYPAD CONSTANTS
                                 .equ PORTLDIR = 0xF0 ; PD7-4: output, PD3-0, input
                                 .equ INITCOLMASK = 0xEF ; scan from the rightmost column,
                                 .equ INITROWMASK = 0x01 ; scan from the top row
                                 .equ ROWMASK = 0x0F ; for obtaining input from Port D
                                 
                                 .equ secondline = 0b10101000
                                 
                                 .include "macros.asm"
                                 
                                 .macro do_lcd_command
                                 	ldi r16, @0
                                 	rcall lcd_command
                                 	rcall lcd_wait
                                 .endmacro
                                 .macro do_lcd_data
                                 	ldi r16, @0
                                 	rcall lcd_data
                                 	rcall lcd_wait
                                 .endmacro
                                 
                                 .macro do_lcd_data_reg
                                 	mov r16, @0
                                 	rcall lcd_data
                                 	rcall lcd_wait
                                 .endmacro
                                 
                                 .macro clear
                                 	ldi YL, low(@0) ; load the memory address to Y
                                 	ldi YH, high(@0)
                                 	clr temp
                                 	st Y+, temp ; clear the two bytes at @0 in SRAM
                                 	st Y, temp
                                 .endmacro
                                 
                                 .macro resetLCD
                                 	do_lcd_command 0b00111000 ; 2x5x7
                                 	rcall sleep_5ms
                                 	do_lcd_command 0b00111000 ; 2x5x7
                                 	rcall sleep_1ms
                                 	do_lcd_command 0b00111000 ; 2x5x7
                                 	do_lcd_command 0b00111000 ; 2x5x7
                                 	do_lcd_command 0b00001000 ; display off?
                                 	do_lcd_command 0b00000001 ; clear display
                                 	do_lcd_command 0b00000110 ; increment, no display shift
                                 	do_lcd_command 0b00001100 ; Cursor on, bar, no blink
                                 .endmacro
                                 ///////////////////////////////////////////////////////////
                                 
                                 // STACK MACROS //////////////////////
                                 .macro pushStack
                                 	push temp
                                 	push temp1
                                 	push temp2
                                 	in temp, SREG
                                 	push temp ; Prologue starts.
                                 	push YH ; Save all conflict registers in the prologue.
                                 	push YL
                                 	push r25
                                 	push r24 ; Prologue ends.
                                 .endmacro
                                 
                                 .macro pushTemp
                                 	push temp
                                 	push temp1
                                 	push temp2
                                 	in temp, SREG
                                 	push temp ; Prologue starts.
                                 .endmacro
                                 
                                 
                                 .macro popStack
                                 	pop r24 ; Epilogue starts;
                                 	pop r25 ; Restore all conflict registers from the stack.
                                 	pop YL
                                 	pop YH
                                 	pop temp
                                 	out SREG, temp
                                 	pop temp2
                                 	pop temp1
                                 	pop temp
                                 .endmacro
                                 
                                 
                                 .macro popTemp
                                 	pop temp
                                 	out SREG, temp
                                 	pop temp2
                                 	pop temp1
                                 	pop temp
                                 .endmacro
                                 
                                 ///////////////////////////////////////////////////////////////////////////////////
                                 
                                 ///////////		INVENTORY MACROS //////////////////////////////////
                                 .macro setInventory  
                                 	;pushTemp
                                 	;arranges items in 2 byte blocks, 1st byte = stock, 2nd byte = cost
                                 	ldi YL, low(inventory)
                                 	ldi YH, high(inventory)
                                 	ldi temp, 1 ;1
                                 	st Y+, temp
                                 	ldi temp, 1 
                                 	st Y+, temp
                                 	ldi temp, 2 ;2	;  set to 0 for debug, change back to 2 when done
                                 	st Y+, temp
                                 	ldi temp, 2 
                                 	st Y+, temp
                                 	ldi temp, 3 ;3
                                 	st Y+, temp
                                 	ldi temp, 1 
                                 	st Y+, temp
                                 	ldi temp, 4 ;4
                                 	st Y+, temp
                                 	ldi temp, 2 
                                 	st Y+, temp
                                 	ldi temp, 0 ;5
                                 	st Y+, temp
                                 	ldi temp, 1 
                                 	st Y+, temp
                                 	ldi temp, 6 ;6
                                 	st Y+, temp
                                 	ldi temp, 2 
                                 	st Y+, temp
                                 	ldi temp, 7 ;7
                                 	st Y+, temp
                                 	ldi temp, 1 
                                 	st Y+, temp
                                 	ldi temp, 8 ;8
                                 	st Y+, temp
                                 	ldi temp, 2 
                                 	st Y+, temp
                                 	ldi temp, 9 ;9
                                 	st Y+, temp
                                 	ldi temp, 1 
                                 	st Y+, temp
                                 	;ldi YL, low(inventory)
                                 	;ldi YH, high(inventory)
                                 	;popTemp
                                 .endmacro
                                 
                                 // Compares menu to given input
                                 .macro checkIfMenu
                                 	;pushTemp 
                                 	lds temp, menu
                                 	cpi temp, @0
                                 	;popTemp
                                 .endMacro
                                 
                                 // Set menu to given input
                                 .macro setMenu
                                 	;pushTemp
                                 	ldi temp, @0
                                 	sts menu, temp
                                 	;popTemp
                                 .endMacro
                                 
                                 
                                 
                                 
                                 .macro isStockEmpty
                                 	;pushTemp 
                                 	getInventory @0
                                 	lds temp2, currentStock
                                 	cpi temp2, 0
                                 	;popTemp
                                 .endMacro
                                 ////////////////////////////////////////
                                 
                                 /////	COIN SCREEN MACROS //////////
                                 .macro incrementCoins
                                 	;pushTemp
                                 	lds temp, coins
                                 	inc temp
                                 	sts coins, temp
                                 	clr temp
                                 	;popTemp
                                 .endMacro
                                 
                                 .macro decrementCoins
                                 	;pushTemp
                                 	lds temp, coins
                                 	dec temp
                                 	sts coins, temp
                                 	clr temp
                                 	;popTemp
                                 .endMacro
                                 
                                 // THIS MACRO UPDATES THE ADMIN SCREEN WHEN WE WANT TO INCREMENT AND DECREMENT
                                 .macro updateAdminScreen
                                 	pushTemp
                                 	resetLCD			;First we reset LCD screen
                                 
                                 	do_lcd_data 'A'
                                 	do_lcd_data 'd'
                                 	do_lcd_data 'm'
                                 	do_lcd_data 'i'
                                 	do_lcd_data 'n'
                                 	do_lcd_data ' '
                                 	do_lcd_data 'M'
                                 	do_lcd_data 'o'
                                 	do_lcd_data 'd'
                                 	do_lcd_data 'e'
                                 	do_lcd_data ' '
                                 
                                 	
                                 	
                                 	lds temp, numPressed			;load in current item and print number
                                 	subi temp, -'0'
                                 	do_lcd_data_reg temp
                                 
                                 	do_lcd_command secondLine		;This writes on the second line
                                 	lds temp, currentStock			;now write current stock
                                 	subi temp, -'0'
                                 	do_lcd_data_reg temp
                                 
                                 	do_lcd_data ' '
                                 	do_lcd_data ' '
                                 	do_lcd_data ' '
                                 	do_lcd_data ' '
                                 	do_lcd_data ' '
                                 	do_lcd_data ' '
                                 	do_lcd_data ' '
                                 	ldi temp, 36
                                 	do_lcd_data_reg temp
                                 
                                 	lds temp, currentCost			;now write cost
                                 	subi temp, -'0'
                                 	do_lcd_data_reg temp
                                 	printLedAdmin
                                 	popTemp
                                 .endMacro
                                 ////////////////////////////////////
                                 
                                 .macro getInventory
                                 	pushTemp
                                 	ldi YH, high(inventory)
                                 	ldi YL, low(inventory)
                                 
                                 ;we want to increment 2(n-1)-1 times as we have to increment Y each time
                                 ; accept n as an integer
                                 	clr temp2		;use temp2 as counter
                                 	mov temp, @0
                                 	dec temp
                                 ;branch case for input of 1, i.e. dont shift just store
                                 	cpi temp, 0
                                 	breq store
                                 
                                 	lsl temp
                                 	dec temp ;in order to get the address 
                                 
                                 increment:
                                 	ld temp1, Y+
                                 	;sts currentStock, temp1
                                 	ld temp1, Y
                                 	;sts currentCost, temp1
                                 
                                 	cp temp, temp2
                                 	breq store
                                 	inc temp2			;increment counter
                                 	rjmp increment
                                 store:
                                 	ld temp1, Y
                                 	sts currentStock, temp1
                                 	ldd temp1, Y + 1
                                 	sts currentCost, temp1
                                 
                                 	popTemp
                                 .endMacro
                                 
                                 
                                 // we want to take current stock value, add one to it and store it in Y
                                 // Y value is obtained by calling getInventory
                                 .macro increaseStock 
                                 	pushTemp
                                 	lds temp2, currentStock
                                 
                                 	cpi temp2, 10   ;check if stock is larger than 10
                                 	breq exit
                                 
                                 	inc temp2		;add one to current stock
                                 	sts currentStock, temp2
                                 	st Y, temp2	
                                 exit:
                                 	popTemp
                                 .endMacro
                                 
                                 .macro decreaseStock 
                                 	pushTemp
                                 	lds temp2, currentStock
                                 	cpi temp2, 0    ;check if equal to zero
                                 	breq exit
                                 	dec temp2		;decrease stock by one
                                 
                                 	sts currentStock, temp2
                                 	st Y, temp2	
                                 exit:
                                 	popTemp
                                 .endMacro
                                 
                                 .macro increaseCost
                                 	pushTemp	
                                 	lds temp2, currentCost	
                                 	cpi temp2, 3		;check if equal to 3
                                 	breq exit
                                 	inc temp2			;Increase cost by one
                                 
                                 	sts currentCost, temp2		;update inventory and currentCost
                                 	std Y + 1, temp2
                                 exit:
                                 	popTemp
                                 .endMacro
                                 
                                 .macro decreaseCost 
                                 	pushTemp
                                 	lds temp2, currentCost
                                 	cpi temp2, 1
                                 	breq exit
                                 	dec temp2
                                 	sts currentCost, temp2		;update inventory and currentCost
                                 	std Y + 1, temp2
                                 exit:
                                 	popTemp
                                 .endMacro
                                 
                                 ///// ADC MACROS /////////////////
                                 .macro setInitialLeft
                                 	push temp
                                 	ldi temp, @0
                                 	sts initialLeft, temp
                                 	pop temp
                                 .endMacro
                                 
                                 .macro setTurnedRight
                                 	push temp
                                 	ldi temp, @0
                                 	sts turnedRight, temp
                                 	pop temp
                                 .endMacro
                                 
                                 .macro setFinalLeft
                                 	push temp
                                 	ldi temp, @0
                                 	sts finalLeft, temp
                                 	pop temp
                                 .endMacro
                                 
                                 .macro setInserted
                                 	push temp
                                 	ldi temp, @0
                                 	sts inserted, temp
                                 	pop temp
                                 .endMacro
                                 
                                 .macro checkIfInitialLeft
                                 	lds temp, initialLeft
                                 	cpi temp, @0
                                 .endMacro
                                 
                                 .macro checkIfFinalLeft
                                 	lds temp, finalLeft
                                 	cpi temp, @0
                                 .endMacro
                                 
                                 .macro checkIfTurnedRight
                                 	lds temp, turnedRight
                                 	cpi temp, @0
                                 .endMacro
                                 
                                 .macro checkIfInserted
                                 	lds temp, inserted
                                 	cpi temp, @0
                                 .endMacro
                                 ///////////////////////////////
                                 //MOTOR
                                 
                                 .macro startMotor
                                 	push temp
                                 	ldi temp, 0b00010000
                                 	out PORTE, temp
                                 	pop temp
                                 .endMacro
                                 
                                 .macro stopMotor
                                 	push temp
                                 	ldi temp, 0b00000000
                                 	out PORTE, temp
                                 	pop temp
                                 .endmacro
                                 
                                 .macro printLedAdmin
                                 	pushTemp
                                 	lds temp, currentStock
                                 	
                                 	cpi temp, 9
                                 	brlo clearG
                                 	ldi temp1, 0b00000001
                                 	out PORTG, temp1
                                 	
                                 	cpi temp, 10
                                 	brlo mainpart
                                 	ldi temp1, 0b00000011
                                 	out PORTG, temp1
                                 	rjmp mainpart
                                 
                                 	clearG:
                                 	clr temp1
                                 	out PORTG, temp1
                                 	;sts adminPattern, temp1
                                 
                                 	mainpart:
                                 	clr temp1
                                 	cpi temp, 0
                                 	breq exit
                                 
                                 	loop:
                                 	lsl temp1
                                 	subi temp1, - 1
                                 	dec temp
                                 	cpi temp, 0
                                 	breq exit
                                 	rjmp loop
                                 
                                 exit:
                                 	out portc, temp1
                                 	popTemp
                                 
                                 
                                 .dseg
000200                           	menu: .byte 1 ; menu screen 1-7
000201                           	coins: .byte 1 ;keeps track of number of coins entered so far
                                 // TIMERS //
                                 TimeCounter:
000202                           	.byte 2 ; Two-byte counter for counting seconds.
                                 TempCounter:; Counts quater seconds 
000204                           	.byte 2 ; Temporary counter. Used to determine
                                 timer1:		; for start screen
000206                           	.byte 1
                                 timer3:		; for Out of stock screen
000207                           	.byte 1
                                 timer6:     ; Used for entering admin mode
000208                           	.byte 1
                                 
                                 // KEYPAD
                                 numPressed:		; current number pressed
000209                           	.byte 1
                                 prevNum:		; previous number pressed
00020a                           	.byte 1
                                 
                                 sound:			; beep static for 250ms
00020b                           	.byte 1
                                 //INSERT COIN
00020c                           initialLeft: .byte 1
00020d                           turnedRight: .byte 1
                                 ;finalLeft: .byte 1
00020e                           inserted: .byte 1
00020f                           coinsForReturn : .byte 1
000210                           coinReturnTime: .byte 1
                                 currentStock:
000211                           	.byte 1
                                 currentCost:
000212                           	.byte 1
                                 pattern:
000213                           	.byte 1 //pattern for leds atm flash only
                                 
                                 //INTERUPTS
                                 .cseg
                                 	.org 0
000000 940c 0234                 		jmp RESET
                                 	.org INT0addr
000002 940c 05c8                 		jmp EXT_INT0
                                 	.org INT1addr
000004 940c 0725                 		jmp EXT_INT1   ;push button interrupt
                                 	.org OVF0addr
00002e 940c 0544                 		jmp Timer0OVF ; Jump to the interrupt handler for
                                 						; Timer0 overflow.
                                 	.org 0x003A		  ;Address of ADC
00003a 940c 01d2                 		jmp EXT_POT
                                 
                                 
                                 
                                 .include "keypad.asm"
                                 
                                 
                                 colloop:
00003c 3044                      	cpi col, 4
00003d f0a9                      	breq zeroReturnBridge; If all keys are scanned, repeat.
00003e 9360 010b                 	sts PORTL, cmask ; Otherwise, scan a column.
000040 ef1f                      	ldi temp1, 0xFF ; Slow down the scan operation.
                                 delay: 
000041 951a                      	dec temp1
000042 f7f1                      	brne delay
000043 9110 0109                 	lds temp1, PINL ; Read PORTL
000045 701f                      	andi temp1, ROWMASK ; Get the keypad output value
000046 301f                      	cpi temp1, 0xF ; Check if any row is low
000047 f081                      	breq nextcol
                                 	; If yes, find which row is low
000048 e051                      	ldi rmask, INITROWMASK ; Initialize for row check
000049 2733                      	clr row ; 
                                 
                                 rowloop:
00004a 3034                      	cpi row, 4
00004b f061                      	breq nextcol ; the row scan is over.
00004c 2f21                      	mov temp2, temp1
00004d 2325                      	and temp2, rmask ; check un-masked bit
00004e f069                      	breq convert ; if bit is clear, the key is pressed
00004f 9533                      	inc row ; else move to the next row
000050 0f55                      	lsl rmask
000051 940c 004a                 	jmp rowloop
                                 
                                 zeroReturnBridge: // NO KEYS ARE SCANNED PREVIOUS NUMBER = 0!
000053 e000                      	ldi temp, 0
000054 9300 020a                 	sts prevNum, temp
000056 940c 01d1                 	jmp returnKeypad
                                 
                                 nextcol: ; if row scan is over
000058 0f66                      	lsl cmask
000059 9543                      	inc col ; increase column value
00005a 940c 003c                 	jmp colloop ; go to the next column
                                 
                                 convert:
00005c 9100 0200
00005e 3001                      	checkIfMenu 1			;if menu is 1 call select screen on button touch
00005f f0c9                      	breq branchSelectScreenBridge 
                                 	
000060 3043                      	cpi col, 3 ; If the pressed key is in col.3
000061 f089                      	breq lettersBridge ; we have a letter
                                 	; If the key is not in col.3 and
000062 3033                      	cpi row, 3 ; If the key is in row3,
000063 f099                      	breq symbolsBridge ; we have a symbol or 0
000064 2f73                      	mov r23, row ; Otherwise we have a number in 1-9
000065 0f77                      	lsl r23
000066 0f73                      	add r23, row
000067 0f74                      	add r23, col ; r23 = row*3 + col
000068 5f7f                      	subi r23, -1 ; r23 = row*3 + col + '1'
                                 	
000069 9100 0200
00006b 3002                      	checkIfMenu 2			//check if on menu 2 if not jump to end
00006c f041                      	breq storeKeypadBridge1
00006d 9100 0200
00006f 3006                      	checkIfMenu 6			//check if in admin mode
000070 f051                      	breq updateAdminBridge	//if in admin mode, we need to store the current press and display it and its variables
000071 940c 01d1                 	jmp returnKeypad		
                                 
                                 	// Relative Key Branches
                                 lettersBridge:
000073 940c 00a1                 	jmp letters
                                 storeKeyPadBridge1:
000075 940c 0106                 	jmp storeKeyPad
                                 symbolsBridge:
000077 940c 00da                 	jmp symbols
                                 branchSelectScreenBridge:
000079 940c 0102                 	jmp branchSelectScreen
                                 updateAdminBridge:
                                 
00007b 930f
00007c 931f
00007d 932f
00007e b70f
00007f 930f
000080 e0d2
000081 e1c4
000082 2722
000083 2f07
000084 950a
000085 3000
000086 f041
000087 0f00
000088 950a
000089 9119
00008a 8118
00008b 1702
00008c f011
00008d 9523
00008e cffa
00008f 8118
000090 9310 0211
000092 8119
000093 9310 0212
000095 910f
000096 bf0f
000097 912f
000098 911f
000099 910f                         	getInventory r23
00009a 9370 0209                     sts numPressed, r23		// here we store the number pressed from the keypad to update into our display
00009c b978                      	out portc, r23
                                 			
00009d 940c 013b                 	jmp updateAdmin         // possibly have two updates one for the items attributes another to increment that item.
                                 							// Here we need to load a new item (getInventory) 
                                 returnKeyPadBridge1:
00009f 940c 01d1                 	jmp returnKeyPad
                                 
                                 letters:
                                 A:
0000a1 e471                      	ldi r23, 'A'
0000a2 0f73                      	add r23, row ; Get the ASCII value for the key
                                 
0000a3 9100 0200
0000a5 3006                      	checkIfMenu 6				; check if in admin mode. If we are we now wait for A, B and C
0000a6 f7c1                      	brne returnKeypadBridge1	
                                 	
0000a7 3471                      	cpi r23, 'A'				; First check if A is pressed
0000a8 f499                      	brne B
                                 
0000a9 930f
0000aa 931f
0000ab 932f
0000ac b70f
0000ad 930f
0000ae 9120 0212
0000b0 3023
0000b1 f021
0000b2 9523
0000b3 9320 0212
0000b5 8329
0000b6 910f
0000b7 bf0f
0000b8 912f
0000b9 911f
0000ba 910f                      	increaseCost				;if it is we increase the cost of the current item (doesn't work)
0000bb c04a                      	rjmp storeKeypad
                                 B:						
0000bc 3472                      	cpi r23, 'B'				;Check if B is pressed
0000bd f499                      	brne C
0000be 930f
0000bf 931f
0000c0 932f
0000c1 b70f
0000c2 930f
0000c3 9120 0212
0000c5 3021
0000c6 f021
0000c7 952a
0000c8 9320 0212
0000ca 8329
0000cb 910f
0000cc bf0f
0000cd 912f
0000ce 911f
0000cf 910f                      	decreaseCost				;If its pressed decrease cost of current item (doesn't work)
0000d0 c035                      	rjmp storeKeypad			
                                 C:
0000d1 e000                      	ldi temp, 0					;Check if C is pressed
0000d2 9300 0211                 	sts currentStock, temp		; If pressed make stock 0
0000d4 8308                      	st Y, temp
0000d5 c030                      	rjmp storeKeypad			
                                 
                                 // Bridges for rjmps
                                 storeKeyPadBridge:	
0000d6 940c 0106                 	jmp storeKeyPad
                                 
                                 returnKeyPadBridge:
0000d8 940c 01d1                 	jmp returnKeyPad
                                 
                                 symbols:
0000da 3040                      	cpi col, 0 ; Check if we have a star
0000db f0a9                      	breq star
0000dc 3041                      	cpi col, 1 ; or if we have zero
0000dd f109                      	breq zero
0000de e273                      	ldi r23, '#' ; if not we have hash
                                 
0000df 9110 020f                 	lds temp1, coinsForReturn
0000e1 0f11                      	lsl temp1
0000e2 9310 0210                 	sts coinReturnTime, temp1
0000e4 e010                      	ldi temp1, 0
0000e5 9310 020f                 	sts coinsForReturn, temp1
                                 	;rcall sleep_25ms
                                 
0000e7 9100 0200
0000e9 3004                      	checkIfMenu 4			;if on insert coins screen move to select screen
0000ea f0b9                      	breq branchSelectScreen
                                 
0000eb 9100 0200
0000ed 3006                      	checkIfMenu 6			;if in admin mode move to select screen :)
0000ee f099                      	breq branchSelectScreen
0000ef 940c 01d1                 	jmp returnKeypad
                                 star:
0000f1 e27a                      	ldi r23, '*'		; Set to star
0000f2 9100 0200
0000f4 3002                      	checkIfMenu 2		; ADMIN MODE requires setScreen menu (2)
0000f5 f711                      	brne returnKeypadBridge
                                 
0000f6 9100 020a                 	lds temp, prevNum	;at this point prevNum is previous value of the keypad
0000f8 320a                      	cpi temp, '*'		;now check previous value of numpressed was '*' so we dont reset the timer
0000f9 f061                      	breq storeKeypad	;store next '*' into numPressed
                                 
0000fa e104                      	ldi temp, 20		;store 20 into timer5 to measure 5 secs for admin mode
0000fb 9300 0208                 	sts timer6, temp	
0000fd 940c 0106                 	jmp storeKeypad		
                                 zero:
0000ff e070                      	ldi r23, 0 ; Set to zero
000100 940c 01d1                 	jmp returnKeypad
                                 
                                 branchSelectScreen:
000102 d216                      	rcall selectScreen	
000103 c0cd                      	rjmp returnKeypad
                                 branchOOSScreen:
000104 d26a                      	rcall outOfStockScreen
000105 c0cb                      	rjmp returnKeypad
                                 
                                 // Store keypad when we need output value otherwise return
                                 storeKeypad:
000106 9100 0200
000108 3006                      	checkIfMenu 6			; if in menu 6 (Admin mode), dont store numpressed as we will set it with digit code. This just handles A,B and C
000109 f189                      	breq updateAdmin		; update admin menu that writes the new values for changed item attributes
                                 
00010a 9370 0209                 	sts numPressed, r23   //here we store r23 into numpressed just cause...
00010c 327a                      	cpi r23, '*'			; if * is pressed return and store it in previous
00010d f151                      	breq storePrev
                                 
00010e 9100 0200
000110 3002                      	checkIfMenu 2			//check again if menu = 2 
000111 f631                      	brne returnKeypadBridge		//if it doesn't jump to end, if it does do macro
000112 930f
000113 931f
000114 932f
000115 b70f
000116 930f
000117 e0d2
000118 e1c4
000119 2722
00011a 2f07
00011b 950a
00011c 3000
00011d f041
00011e 0f00
00011f 950a
000120 9119
000121 8118
000122 1702
000123 f011
000124 9523
000125 cffa
000126 8118
000127 9310 0211
000129 8119
00012a 9310 0212
00012c 910f
00012d bf0f
00012e 912f
00012f 911f
000130 910f
000131 9120 0211
000133 3020                      	isStockEmpty r23		//if true, branch to the out of stock screen
000134 f279                      	breq branchOOSScreen
                                 	
000135 d28a                      	rcall coinScreen
000136 940c 01d1                 	jmp returnKeypad
                                 
                                 storePrev:
000138 9370 020a                 	sts prevNum, r23
00013a c096                      	rjmp returnKeypad
                                 updateAdmin:
00013b 930f
00013c 931f
00013d 932f
00013e b70f
00013f 930f
000140 e308
000141 d741
000142 d750
000143 d769
000144 e308
000145 d73d
000146 d74c
000147 d75c
000148 e308
000149 d739
00014a d748
00014b e308
00014c d736
00014d d745
00014e e008
00014f d733
000150 d742
000151 e001
000152 d730
000153 d73f
000154 e006
000155 d72d
000156 d73c
000157 e00c
000158 d72a
000159 d739
00015a e401
00015b d72e
00015c d736
00015d e604
00015e d72b
00015f d733
000160 e60d
000161 d728
000162 d730
000163 e609
000164 d725
000165 d72d
000166 e60e
000167 d722
000168 d72a
000169 e200
00016a d71f
00016b d727
00016c e40d
00016d d71c
00016e d724
00016f e60f
000170 d719
000171 d721
000172 e604
000173 d716
000174 d71e
000175 e605
000176 d713
000177 d71b
000178 e200
000179 d710
00017a d718
00017b 9100 0209
00017d 5d00
00017e 2f00
00017f d70a
000180 d712
000181 ea08
000182 d700
000183 d70f
000184 9100 0211
000186 5d00
000187 2f00
000188 d701
000189 d709
00018a e200
00018b d6fe
00018c d706
00018d e200
00018e d6fb
00018f d703
000190 e200
000191 d6f8
000192 d700
000193 e200
000194 d6f5
000195 d6fd
000196 e200
000197 d6f2
000198 d6fa
000199 e200
00019a d6ef
00019b d6f7
00019c e200
00019d d6ec
00019e d6f4
00019f e204
0001a0 2f00
0001a1 d6e8
0001a2 d6f0
0001a3 9100 0212
0001a5 5d00
0001a6 2f00
0001a7 d6e2
0001a8 d6ea
0001a9 930f
0001aa 931f
0001ab 932f
0001ac b70f
0001ad 930f
0001ae 9100 0211
0001b0 3009
0001b1 f038
0001b2 e011
0001b3 bb14
0001b4 300a
0001b5 f028
0001b6 e013
0001b7 bb14
0001b8 c002
0001b9 2711
0001ba bb14
0001bb 2711
0001bc 3000
0001bd f031
0001be 0f11
0001bf 5f1f
0001c0 950a
0001c1 3000
0001c2 f009
0001c3 cffa
0001c4 b918
0001c5 910f
0001c6 bf0f
0001c7 912f
0001c8 911f
0001c9 910f
0001ca 910f
0001cb bf0f
0001cc 912f
0001cd 911f
0001ce 910f                      	updateAdminScreen
0001cf 9100 0212                 	lds temp, currentCost
                                 	;out portc, temp	
                                 
                                 returnKeypad:
0001d1 9508                      	ret
                                 	
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 /*// Instead of temp1 we will use r23 to store the return of this function
                                 
                                 colloop:
                                 	cpi col, 4
                                 	breq returnBridge; If all keys are scanned, repeat.
                                 	sts PORTL, cmask ; Otherwise, scan a column.
                                 	ldi temp1, 0xFF ; Slow down the scan operation.
                                 delay: 
                                 	dec temp1
                                 	brne delay
                                 	lds temp1, PINL ; Read PORTL
                                 	andi temp1, ROWMASK ; Get the keypad output value
                                 	cpi temp1, 0xF ; Check if any row is low
                                 	breq nextcol
                                 	; If yes, find which row is low
                                 	ldi rmask, INITROWMASK ; Initialize for row check
                                 	clr row ; 
                                 
                                 rowloop:
                                 	cpi row, 4
                                 	breq nextcol ; the row scan is over.
                                 	mov temp2, temp1
                                 	and temp2, rmask ; check un-masked bit
                                 	breq convert ; if bit is clear, the key is pressed
                                 	inc row ; else move to the next row
                                 	lsl rmask
                                 	jmp rowloop
                                 
                                 returnBridge: // NO KEYS ARE SCANNED PREVIOUS NUMBER = 0!
                                 	ldi temp, 0
                                 	sts prevNum, temp
                                 	jmp returnKeypad
                                 
                                 nextcol: ; if row scan is over
                                 	lsl cmask
                                 	inc col ; increase column value
                                 	jmp colloop ; go to the next column
                                 
                                 convert:
                                 	//set sound flag for beeper code
                                 	ldi temp, 1
                                 	sts sound, temp 
                                 	///////////////
                                 
                                 	checkIfMenu 1
                                 	breq branchSelectScreen
                                 	;rcall SelectScreen	; try make to rcall
                                 	cpi col, 3 ; If the pressed key is in col.3
                                 	breq letters ; we have a letter
                                 	; If the key is not in col.3 and
                                 	cpi row, 3 ; If the key is in row3,
                                 	breq symbols ; we have a symbol or 0
                                 	mov r23, row ; Otherwise we have a number in 1-9
                                 	lsl r23
                                 	add r23, row
                                 	add r23, col ; r23 = row*3 + col
                                 	subi r23, -1 ; r23 = row*3 + col + '1'
                                 	
                                 	checkIfMenu 2 //check if on menu 2 if not jump to end
                                 	breq storeKeypad
                                 	jmp returnKeypad
                                 
                                 letters:
                                 	ldi r23, 'A'
                                 	add r23, row ; Get the ASCII value for the key
                                 	jmp returnKeypad
                                 symbols:
                                 	cpi col, 0 ; Check if we have a star
                                 	breq star
                                 	cpi col, 1 ; or if we have zero
                                 	breq zero
                                 	ldi r23, '#' ; if not we have hash
                                 
                                 
                                 	lds temp1, coinsforReturn
                                 	lsl temp1
                                 	sts coinReturnTime, temp1  //store coins for return * 2 in coin return time
                                 	ldi temp1, 0
                                 	sts coinsforReturn, temp1 // clear coins for return
                                 	rcall sleep_25ms
                                 
                                 	checkIfMenu 4			;if on insert coins screen move to select screen
                                 	breq branchSelectScreen
                                 
                                 	checkIfMenu 6			;if in admin mode move to select screen :)
                                 	breq branchSelectScreen
                                 
                                 	jmp returnKeypad
                                 star:
                                 	ldi r23, '*'		; Set to star
                                 	checkIfMenu 2		; ADMIN MODE requires setScreen menu (2)
                                 	brne returnKeypad
                                 
                                 	lds temp, prevNum	;at this point prevNum is previous value of the keypad
                                 	cpi temp, '*'		;now check previous value of numpressed was '*' so we dont reset the timer
                                 	breq storeKeypad	;store next '*' into numPressed
                                 
                                 	ldi temp, 20		;store 20 into timer5 to measure 5 secs for admin mode
                                 	sts timer6, temp	
                                 	jmp storeKeypad		
                                 zero:
                                 	ldi r23, 0 ; Set to zero
                                 	jmp returnKeypad
                                 
                                 branchSelectScreen:
                                 	rcall selectScreen	
                                 	rjmp returnKeypad
                                 
                                 branchOOSScreen:
                                 	rcall outOfStockScreen
                                 	rjmp returnKeypad
                                 
                                 // Store keypad when we need output value otherwise return
                                 storeKeypad:
                                 	sts numPressed, r23   //here we store r23 into numpressed just cause...
                                 	cpi r23, '*'			; if * is pressed return and store it in previous
                                 	breq storePrev
                                 
                                 	checkIfMenu 2			//check again if menu = 2 
                                 	brne returnKeypad		//if it doesn't jump to end, if it does do macro
                                 	isStockEmpty r23		//if true, branch to the out of stock screen
                                 	breq branchOOSScreen
                                 	
                                 	rcall coinScreen
                                 	jmp returnKeypad
                                 
                                 storePrev:
                                 	sts prevNum, r23
                                 
                                 returnKeypad:	
                                 	ret
                                 	
                                 
                                 .include "inventory.asm"
                                 
                                 ;.def temp1 = r17	;n  = holds item num
                                 ;.def temp2 = r18	; counter = for incrementing
                                 
                                 .dseg
                                 inventory: 
000214                           	.byte 18
                                 .cseg 
                                 //setInventory
                                 
                                 //temp1 = position wanted
                                 
                                 
                                 
                                 
                                 .include "pot.asm"
                                 
                                 EXT_POT:
0001d2 930f
0001d3 931f
0001d4 932f
0001d5 b70f
0001d6 930f
0001d7 93df
0001d8 93cf
0001d9 939f
0001da 938f                      	pushStack
0001db 91e0 0078                 	lds ZL, ADCL
0001dd 91f0 0079                 	lds ZH, ADCH
                                 
0001df ec00                      	ldi temp, (3 << REFS0) | (0 << ADLAR) | (0 << MUX0)
0001e0 9300 007c                 	sts ADMUX, temp
0001e2 e008                      	ldi temp, (1 << MUX5)
0001e3 9300 007b                 	sts ADCSRB, temp
0001e5 ec0d                      	ldi temp, (1 << ADEN) | (1 << ADSC) | (1 << ADIE) | (5 << ADPS0)
0001e6 9300 007a                 	sts ADCSRA, temp
                                 
0001e8 30e0                      	cpi ZL, low(0x000)		//potentiometer is turned left
0001e9 e010                      	ldi temp1, high(0x000)
0001ea 07f1                      	cpc ZH, temp1
0001eb f071                      	breq potLeft
                                 
0001ec 3fef                      	cpi ZL, low(0x3FF)		//potentiometer is turned right
0001ed e013                      	ldi temp1, high(0x3FF)
0001ee 07f1                      	cpc ZH, temp1
0001ef f0b9                      	breq potRight
                                 
                                 	returnPot:
0001f0 918f
0001f1 919f
0001f2 91cf
0001f3 91df
0001f4 910f
0001f5 bf0f
0001f6 912f
0001f7 911f
0001f8 910f                      		popStack
0001f9 9518                      		reti
                                 
                                 potLeft:
0001fa 9100 0200
0001fc 3004                      	checkIfMenu 4
0001fd f791                      	brne returnPot
                                 	
0001fe 9100 020d
000200 3000                      	checkIfTurnedRight 0
000201 f161                      	breq incInitialLeft
                                 
000202 9100 020e
000204 3001                      	checkifInserted 1
000205 f051                      	breq coinInserted
000206 cfe9                      	rjmp returnPot
                                 
                                 potRight:
000207 9100 0200
000209 3004                      	checkIfMenu 4
00020a f729                      	brne returnPot
00020b 9100 020c
00020d 3001                      	checkIfInitialLeft 1
00020e f0a1                      	breq incTurnedRight 
00020f cfe0                      	rjmp returnPot
                                 
                                 coinInserted:
000210 9100 0201                 	lds temp, coins
000212 0f00                      	lsl temp
000213 9503                      	inc temp
000214 9300 0201                 	sts coins, temp
000216 b908                      	out PORTC, temp
000217 930f
000218 e000
000219 9300 020e
00021b 910f                      	setInserted 0
                                 
00021c 9110 020f                 	lds temp1, coinsforReturn //increment coins for return when pot is triggered
00021e 9513                      	inc temp1  
00021f 9310 020f                 	sts coinsForReturn, temp1
000221 d19e                      	rcall coinScreen
000222 cfcd                      	rjmp returnPot
                                 
                                 incTurnedRight:
000223 930f
000224 e001
000225 9300 020d
000227 910f                      	setTurnedRight 1
000228 930f
000229 e001
00022a 9300 020e
00022c 910f                      	setInserted 1
00022d cfc2                      	rjmp returnPot
                                 	
                                 incInitialLeft:
00022e 930f
00022f e001
000230 9300 020c
000232 910f                      	setInitialLeft 1
000233 cfbc                      	rjmp returnPot
                                 
                                 
                                 RESET:
                                 	// INTIATE STACK
000234 ef0f                      	ldi r16, low(RAMEND)
000235 bf0d                      	out SPL, r16
000236 e201                      	ldi r16, high(RAMEND)
000237 bf0e                      	out SPH, r16
                                 
                                 	// LCD RESET
000238 ef0f                      	ser r16
000239 bb00                      	out DDRF, r16
00023a b907                      	out DDRC, r16
00023b b901                      	out DDRA, r16
00023c bb03                      	out DDRG, r16
00023d 2700                      	clr r16
00023e bb01                      	out PORTF, r16
00023f b902                      	out PORTA, r16
000240 b908                      	out PORTC, r16
000241 bb04                      	out PORTG, r16
                                 
                                 	// TIMER RESET//
000242 e0c4
000243 e0d2
000244 2700
000245 9309
000246 8308                      	clear TempCounter ; Initialize the temporary counter to 0
000247 e0c2
000248 e0d2
000249 2700
00024a 9309
00024b 8308                      	clear TimeCounter ; Initialize the second counter to 0
00024c e000                      	ldi temp, 0b00000000
00024d bd04                      	out TCCR0A, temp
00024e e002                      	ldi temp, 0b00000010
00024f bd05                      	out TCCR0B, temp ; Prescaling value=8
000250 e001                      	ldi temp, 1<<TOIE0 ; = 128 microseconds
000251 9300 006e                 	sts TIMSK0, temp ; T/C0 interrupt enable
                                 
                                 
                                 	// KEYPAD RESET
000253 ef10                      	ldi temp1, PORTLDIR ; PA7:4/PA3:0, out/in
000254 9310 010a                 	sts DDRL, temp1
                                 
                                 	// PUSH BUTTON INITIALISATION 
000256 e002                      	ldi temp, (2<<ISC00)	;set INT0 as falling edge triggered interupt
000257 9300 0069                 	sts EICRA, temp
000259 b30d                      	in temp, EIMSK			;enable INT0 & INT1
00025a 6001                      	ori temp, (1<<INT0)
00025b 6002                      	ori temp, (1<<INT1)
00025c bb0d                      	out EIMSK, temp
                                 
                                 	// ADC INIT
00025d ec00                      	ldi temp, (3 << REFS0) | (0 << ADLAR) | (0 << MUX0)
00025e 9300 007c                 	sts ADMUX, temp
000260 e008                      	ldi temp, (1 << MUX5)
000261 9300 007b                 	sts ADCSRB, temp
000263 ec0d                      	ldi temp, (1 << ADEN) | (1 << ADSC) | (1 << ADIE) | (5 << ADPS0)
000264 9300 007a                 	sts ADCSRA, temp
                                 
000266 ef0f                      	ser temp              //MOTOR IS PIN 3
000267 b90d                      	out DDRE, temp
000268 2700                      	clr temp
000269 b90e                      	out PORTE, temp
00026a ef0f                      	ser temp              //SOUND IS PIN 0
00026b b904                      	out DDRB, temp
00026c 2700                      	clr temp
00026d b905                      	out PORTB, temp
                                 
00026e 9478                      	sei ; Enable global interrupt
                                 
                                 	// INVENTORY INITIALISATION
00026f e1c4
000270 e0d2
000271 e001
000272 9309
000273 e001
000274 9309
000275 e002
000276 9309
000277 e002
000278 9309
000279 e003
00027a 9309
00027b e001
00027c 9309
00027d e004
00027e 9309
00027f e002
000280 9309
000281 e000
000282 9309
000283 e001
000284 9309
000285 e006
000286 9309
000287 e002
000288 9309
000289 e007
00028a 9309
00028b e001
00028c 9309
00028d e008
00028e 9309
00028f e002
000290 9309
000291 e009
000292 9309
000293 e001
000294 9309                      	setInventory
                                 
                                 	// CONSTANTS
000295 e000                      	ldi temp, 0
000296 9300 0201                 	sts coins, temp
000298 9300 020f                 	sts coinsForReturn, temp
00029a 9300 0210                 	sts coinReturnTime,temp
                                 
00029c d001                      	rcall startScreen
00029d c2a2                      	rjmp main			;go to main to start polling, reset finished
                                 
                                 startScreen: ;start screen is part of reset function
00029e e001
00029f 9300 0200                 	setMenu 1
                                 	;out portc, temp
                                 
0002a1 e308
0002a2 d5e0
0002a3 d5ef
0002a4 d608
0002a5 e308
0002a6 d5dc
0002a7 d5eb
0002a8 d5fb
0002a9 e308
0002aa d5d8
0002ab d5e7
0002ac e308
0002ad d5d5
0002ae d5e4
0002af e008
0002b0 d5d2
0002b1 d5e1
0002b2 e001
0002b3 d5cf
0002b4 d5de
0002b5 e006
0002b6 d5cc
0002b7 d5db
0002b8 e00c
0002b9 d5c9
0002ba d5d8                      	resetLCD
                                 
0002bb e302
0002bc d5cd
0002bd d5d5                      	do_lcd_data '2'
0002be e301
0002bf d5ca
0002c0 d5d2                      	do_lcd_data '1'
0002c1 e302
0002c2 d5c7
0002c3 d5cf                      	do_lcd_data '2'
0002c4 e301
0002c5 d5c4
0002c6 d5cc                      	do_lcd_data '1'
0002c7 e200
0002c8 d5c1
0002c9 d5c9                      	do_lcd_data ' '
0002ca e301
0002cb d5be
0002cc d5c6                      	do_lcd_data '1'
0002cd e307
0002ce d5bb
0002cf d5c3                      	do_lcd_data '7'
0002d0 e703
0002d1 d5b8
0002d2 d5c0                      	do_lcd_data 's'
0002d3 e301
0002d4 d5b5
0002d5 d5bd                      	do_lcd_data '1'
0002d6 e200
0002d7 d5b2
0002d8 d5ba                      	do_lcd_data ' '
0002d9 e200
0002da d5af
0002db d5b7                      	do_lcd_data ' '
0002dc e200
0002dd d5ac
0002de d5b4                      	do_lcd_data ' '
0002df e401
0002e0 d5a9
0002e1 d5b1                      	do_lcd_data 'A'
0002e2 e304
0002e3 d5a6
0002e4 d5ae                      	do_lcd_data '4'
                                 
0002e5 ea08
0002e6 d59c
0002e7 d5ab                      	do_lcd_command secondLine
                                 
0002e8 e506
0002e9 d5a0
0002ea d5a8                      	do_lcd_data 'V'
0002eb e605
0002ec d59d
0002ed d5a5                      	do_lcd_data 'e'
0002ee e60e
0002ef d59a
0002f0 d5a2                      	do_lcd_data 'n'
0002f1 e604
0002f2 d597
0002f3 d59f                      	do_lcd_data 'd'
0002f4 e609
0002f5 d594
0002f6 d59c                      	do_lcd_data 'i'
0002f7 e60e
0002f8 d591
0002f9 d599                      	do_lcd_data 'n'
0002fa e607
0002fb d58e
0002fc d596                      	do_lcd_data 'g'
0002fd e200
0002fe d58b
0002ff d593                      	do_lcd_data ' '
000300 e40d
000301 d588
000302 d590                      	do_lcd_data 'M'
000303 e601
000304 d585
000305 d58d                      	do_lcd_data 'a'
000306 e603
000307 d582
000308 d58a                      	do_lcd_data 'c'
000309 e608
00030a d57f
00030b d587                      	do_lcd_data 'h'
00030c e609
00030d d57c
00030e d584                      	do_lcd_data 'i'
00030f e60e
000310 d579
000311 d581                      	do_lcd_data 'n'
000312 e605
000313 d576
000314 d57e                      	do_lcd_data 'e'
                                 
000315 e00c                      	ldi temp, 12	; for 3 seconds, intitilise to 13, because every 0.25s x 4 = 1 *3 = 12;
000316 9300 0206                 	sts timer1, temp
000318 9508                      	ret
                                 
                                 selectScreen:
                                 	
                                 	// if coming from insertCoin screen, we need to clear coins, clear leds, and keep the value of coins in coinsforreturn
000319 9100 0200
00031b 3004                      	checkIfMenu 4
00031c f499                      	brne test
                                 	//lds temp, coinsForReturn
                                 	//lsl temp
                                 	//sts coinsForReturn, temp
                                 	//inc temp
                                 	//out portc, temp
                                 	//sts coinsForReturn, temp
                                 
00031d e000                      	ldi temp, 0
00031e 9300 0201                 	sts coins, temp
000320 b908                      	out PORTC, temp
000321 930f
000322 e000
000323 9300 020e
000325 910f                      	setInserted 0
000326 930f
000327 e000
000328 9300 020c
00032a 910f                      	setInitialLeft 0
00032b 930f
00032c e000
00032d 9300 020d
00032f 910f                      	setTurnedRight 0
                                 
                                 	test:
000330 e002
000331 9300 0200                 	setMenu 2
                                 	;out portc, temp
                                 
000333 e308
000334 d54e
000335 d55d
000336 d576
000337 e308
000338 d54a
000339 d559
00033a d569
00033b e308
00033c d546
00033d d555
00033e e308
00033f d543
000340 d552
000341 e008
000342 d540
000343 d54f
000344 e001
000345 d53d
000346 d54c
000347 e006
000348 d53a
000349 d549
00034a e00c
00034b d537
00034c d546                      	resetLCD
                                 
00034d e503
00034e d53b
00034f d543                      	do_lcd_data 'S'
000350 e605
000351 d538
000352 d540                      	do_lcd_data 'e'
000353 e60c
000354 d535
000355 d53d                      	do_lcd_data 'l'
000356 e605
000357 d532
000358 d53a                      	do_lcd_data 'e'
000359 e603
00035a d52f
00035b d537                      	do_lcd_data 'c'
00035c e704
00035d d52c
00035e d534                      	do_lcd_data 't'
00035f e200
000360 d529
000361 d531                      	do_lcd_data ' '
000362 e409
000363 d526
000364 d52e                      	do_lcd_data 'I'
000365 e704
000366 d523
000367 d52b                      	do_lcd_data 't'
000368 e605
000369 d520
00036a d528                      	do_lcd_data 'e'
00036b e60d
00036c d51d
00036d d525                      	do_lcd_data 'm'
00036e 9508                      	ret
                                 
                                 //menu 3
                                 outOfStockScreen:
00036f e308
000370 d512
000371 d521
000372 d53a
000373 e308
000374 d50e
000375 d51d
000376 d52d
000377 e308
000378 d50a
000379 d519
00037a e308
00037b d507
00037c d516
00037d e008
00037e d504
00037f d513
000380 e001
000381 d501
000382 d510
000383 e006
000384 d4fe
000385 d50d
000386 e00c
000387 d4fb
000388 d50a                      	resetLCD
                                 
000389 e40f
00038a d4ff
00038b d507                      	do_lcd_data 'O'
00038c e705
00038d d4fc
00038e d504                      	do_lcd_data 'u'
00038f e704
000390 d4f9
000391 d501                      	do_lcd_data 't'
000392 e200
000393 d4f6
000394 d4fe                      	do_lcd_data ' '
000395 e60f
000396 d4f3
000397 d4fb                      	do_lcd_data 'o'
000398 e606
000399 d4f0
00039a d4f8                      	do_lcd_data 'f'
00039b e200
00039c d4ed
00039d d4f5                      	do_lcd_data ' '
00039e e503
00039f d4ea
0003a0 d4f2                      	do_lcd_data 'S'
0003a1 e704
0003a2 d4e7
0003a3 d4ef                      	do_lcd_data 't'
0003a4 e60f
0003a5 d4e4
0003a6 d4ec                      	do_lcd_data 'o'
0003a7 e603
0003a8 d4e1
0003a9 d4e9                      	do_lcd_data 'c'
0003aa e60b
0003ab d4de
0003ac d4e6                      	do_lcd_data 'k'
                                 
0003ad ea08
0003ae d4d4
0003af d4e3                      	do_lcd_command secondLine
                                 
                                 	;out PORTC, temp1
0003b0 9110 0209                 	lds temp1, numPressed
0003b2 5d10                      	subi temp1, -'0'
0003b3 2f01
0003b4 d4d5
0003b5 d4dd                      	do_lcd_data_reg temp1		;temp1 holds what key was pressed, we convert it to ascii, print it out to lcd
                                 
                                 
                                 	;We will have a check to see when this equals 6 i.e. 1.5secs to toggle led's
0003b6 e003
0003b7 9300 0200                 	setMenu 3
0003b9 e00c                      	ldi temp, 12	;for 3 seconds, intitilise to 12, because every 0.25s x 4 = 1 *3 = 12;
0003ba 9300 0207                 	sts timer3, temp
0003bc e000                      	ldi temp, 0b00000000
0003bd 9300 0213                 	sts pattern, temp
0003bf 9508                      	ret
                                 
                                 coinScreen:
0003c0 e004
0003c1 9300 0200                 	setMenu 4
                                 
0003c3 e308
0003c4 d4be
0003c5 d4cd
0003c6 d4e6
0003c7 e308
0003c8 d4ba
0003c9 d4c9
0003ca d4d9
0003cb e308
0003cc d4b6
0003cd d4c5
0003ce e308
0003cf d4b3
0003d0 d4c2
0003d1 e008
0003d2 d4b0
0003d3 d4bf
0003d4 e001
0003d5 d4ad
0003d6 d4bc
0003d7 e006
0003d8 d4aa
0003d9 d4b9
0003da e00c
0003db d4a7
0003dc d4b6                      	resetLCD
                                 
0003dd e409
0003de d4ab
0003df d4b3                      	do_lcd_data 'I'
0003e0 e60e
0003e1 d4a8
0003e2 d4b0                      	do_lcd_data 'n'
0003e3 e703
0003e4 d4a5
0003e5 d4ad                      	do_lcd_data 's'
0003e6 e605
0003e7 d4a2
0003e8 d4aa                      	do_lcd_data 'e'
0003e9 e702
0003ea d49f
0003eb d4a7                      	do_lcd_data 'r'
0003ec e704
0003ed d49c
0003ee d4a4                      	do_lcd_data 't'
0003ef e200
0003f0 d499
0003f1 d4a1                      	do_lcd_data ' '
0003f2 e403
0003f3 d496
0003f4 d49e                      	do_lcd_data 'C'
0003f5 e60f
0003f6 d493
0003f7 d49b                      	do_lcd_data 'o'
0003f8 e609
0003f9 d490
0003fa d498                      	do_lcd_data 'i'
0003fb e60e
0003fc d48d
0003fd d495                      	do_lcd_data 'n'
0003fe e703
0003ff d48a
000400 d492                      	do_lcd_data 's'
                                 
000401 ea08
000402 d480
000403 d48f                      	do_lcd_command secondLine
                                 	
                                 	// PRINT TO LED NUMBER OF COINS BEEN ENTERED, LEAVE IN, NOT DEBUGGING!!!!!
000404 9100 0201                 	lds temp, coins
000406 b908                      	out portc, temp
                                 	// SHOW NUMBER OF COINS REMAINING = CURRENTCOST - COINS ENTERED
000407 9110 0212                 	lds temp1, currentCost
000409 9100 020f                 	lds temp, coinsForReturn
00040b 1b10                      	sub temp1, temp
00040c 3011                      	cpi temp1, 1
00040d f02c                      	brlt DeliverScreen
00040e 5d10                      	subi temp1, -'0'
00040f 2f01
000410 d479
000411 d481                      	do_lcd_data_reg temp1
                                 	
000412 9508                      	ret
                                 
                                 DeliverScreen:
000413 e005
000414 9300 0200                 	setMenu 5
                                 
000416 e308
000417 d46b
000418 d47a
000419 d493
00041a e308
00041b d467
00041c d476
00041d d486
00041e e308
00041f d463
000420 d472
000421 e308
000422 d460
000423 d46f
000424 e008
000425 d45d
000426 d46c
000427 e001
000428 d45a
000429 d469
00042a e006
00042b d457
00042c d466
00042d e00c
00042e d454
00042f d463                      	resetLCD
                                 
000430 e404
000431 d458
000432 d460                      	do_lcd_data 'D'
000433 e605
000434 d455
000435 d45d                      	do_lcd_data 'e'
000436 e60c
000437 d452
000438 d45a                      	do_lcd_data 'l'
000439 e609
00043a d44f
00043b d457                      	do_lcd_data 'i'
00043c e706
00043d d44c
00043e d454                      	do_lcd_data 'v'
00043f e605
000440 d449
000441 d451                      	do_lcd_data 'e'
000442 e702
000443 d446
000444 d44e                      	do_lcd_data 'r'
000445 e609
000446 d443
000447 d44b                      	do_lcd_data 'i'
000448 e60e
000449 d440
00044a d448                      	do_lcd_data 'n'
00044b e607
00044c d43d
00044d d445                      	do_lcd_data 'g'
00044e e200
00044f d43a
000450 d442                      	do_lcd_data ' '
000451 e409
000452 d437
000453 d43f                      	do_lcd_data 'I'
000454 e704
000455 d434
000456 d43c                      	do_lcd_data 't'
000457 e605
000458 d431
000459 d439                      	do_lcd_data 'e'
00045a e60d
00045b d42e
00045c d436                      	do_lcd_data 'm'
                                 	
00045d e023                      	ldi temp2, 3    // counter
00045e 930f
00045f 931f
000460 932f
000461 b70f
000462 930f
000463 9120 0211
000465 3020
000466 f021
000467 952a
000468 9320 0211
00046a 8328
00046b 910f
00046c bf0f
00046d 912f
00046e 911f
00046f 910f                      	decreaseStock
000470 930f
000471 e100
000472 b90e
000473 910f                      	startMotor
                                 	timeLoop:
000474 ef1f                      	ser temp1		;flash leds
000475 b918                      	out PORTC, temp1
000476 bb14                      	out PORTG, temp1
                                 
000477 d43b                      	rcall sleep_500ms
                                 
000478 2711                      	clr temp1		;clear leds
000479 b918                      	out PORTC, temp1
00047a bb14                      	out PORTG, temp1
                                 
00047b d437                      	rcall sleep_500ms
                                 
00047c 952a                      	dec temp2
00047d 3020                      	cpi temp2, 0
00047e f7a9                      	brne timeLoop
                                 
00047f 930f
000480 e000
000481 b90e
000482 910f                      	stopMotor
000483 2700                      	clr temp
000484 9300 0201                 	sts coins, temp
000486 9300 020f                 	sts coinsForReturn, temp
000488 ce90                      	rjmp SelectScreen
                                 	;ret
                                 
                                 	///ADMIN MODE
                                 enterAdminMode:
000489 930f
00048a 931f
00048b 932f
00048c b70f
00048d 930f                      	pushTemp
00048e e308
00048f d3f3
000490 d402
000491 d41b
000492 e308
000493 d3ef
000494 d3fe
000495 d40e
000496 e308
000497 d3eb
000498 d3fa
000499 e308
00049a d3e8
00049b d3f7
00049c e008
00049d d3e5
00049e d3f4
00049f e001
0004a0 d3e2
0004a1 d3f1
0004a2 e006
0004a3 d3df
0004a4 d3ee
0004a5 e00c
0004a6 d3dc
0004a7 d3eb                      	resetLCD
                                 
0004a8 e006
0004a9 9300 0200                 	setMenu 6
                                 
0004ab e401
0004ac d3dd
0004ad d3e5                      	do_lcd_data 'A'
0004ae e604
0004af d3da
0004b0 d3e2                      	do_lcd_data 'd'
0004b1 e60d
0004b2 d3d7
0004b3 d3df                      	do_lcd_data 'm'
0004b4 e609
0004b5 d3d4
0004b6 d3dc                      	do_lcd_data 'i'
0004b7 e60e
0004b8 d3d1
0004b9 d3d9                      	do_lcd_data 'n'
0004ba e200
0004bb d3ce
0004bc d3d6                      	do_lcd_data ' '
0004bd e40d
0004be d3cb
0004bf d3d3                      	do_lcd_data 'M'
0004c0 e60f
0004c1 d3c8
0004c2 d3d0                      	do_lcd_data 'o'
0004c3 e604
0004c4 d3c5
0004c5 d3cd                      	do_lcd_data 'd'
0004c6 e605
0004c7 d3c2
0004c8 d3ca                      	do_lcd_data 'e'
0004c9 e200
0004ca d3bf
0004cb d3c7                      	do_lcd_data ' '
                                 
0004cc e001                      	ldi temp, 1
0004cd 9300 0209                 	sts numPressed, temp
0004cf 930f
0004d0 931f
0004d1 932f
0004d2 b70f
0004d3 930f
0004d4 e0d2
0004d5 e1c4
0004d6 2722
0004d7 2f00
0004d8 950a
0004d9 3000
0004da f041
0004db 0f00
0004dc 950a
0004dd 9119
0004de 8118
0004df 1702
0004e0 f011
0004e1 9523
0004e2 cffa
0004e3 8118
0004e4 9310 0211
0004e6 8119
0004e7 9310 0212
0004e9 910f
0004ea bf0f
0004eb 912f
0004ec 911f
0004ed 910f                      	getInventory temp
                                 
0004ee 5d00                      	subi temp, -'0'
0004ef 2f00
0004f0 d399
0004f1 d3a1                      	do_lcd_data_reg temp
                                 
0004f2 ea08
0004f3 d38f
0004f4 d39e                      	do_lcd_command secondLine
0004f5 9100 0211                 	lds temp, currentStock
                                 	;out PORTC, temp
0004f7 5d00                      	subi temp, -'0'
0004f8 2f00
0004f9 d390
0004fa d398                      	do_lcd_data_reg temp
                                 
0004fb e200
0004fc d38d
0004fd d395                      	do_lcd_data ' '
0004fe e200
0004ff d38a
000500 d392                      	do_lcd_data ' '
000501 e200
000502 d387
000503 d38f                      	do_lcd_data ' '
000504 e200
000505 d384
000506 d38c                      	do_lcd_data ' '
000507 e200
000508 d381
000509 d389                      	do_lcd_data ' '
00050a e200
00050b d37e
00050c d386                      	do_lcd_data ' '
00050d e200
00050e d37b
00050f d383                      	do_lcd_data ' '
000510 e200
000511 d378
000512 d380                      	do_lcd_data ' '
                                 
000513 9100 0212                 	lds temp, currentCost
000515 5d00                      	subi temp, -'0'
000516 2f00
000517 d372
000518 d37a                      	do_lcd_data_reg temp
000519 930f
00051a 931f
00051b 932f
00051c b70f
00051d 930f
00051e 9100 0211
000520 3009
000521 f038
000522 e011
000523 bb14
000524 300a
000525 f028
000526 e013
000527 bb14
000528 c002
000529 2711
00052a bb14
00052b 2711
00052c 3000
00052d f031
00052e 0f11
00052f 5f1f
000530 950a
000531 3000
000532 f009
000533 cffa
000534 b918
000535 910f
000536 bf0f
000537 912f
000538 911f
000539 910f                      	printLedAdmin
00053a 910f
00053b bf0f
00053c 912f
00053d 911f
00053e 910f                      	popTemp	
00053f 9508                      	ret
                                 
                                 
                                 // MAIN LOOP TO START POLLING
                                 main:
000540 ee6f                      	ldi cmask, INITCOLMASK	; initial column mask
000541 2744                      	clr col					; initial column
000542 daf9                      	rcall colloop			; continue poll
000543 cffc                      	rjmp main				; loop main to continue polling 
                                 
                                 
                                 ///////////////////////////////////////////////
                                 
                                 
                                 // TIMER 0 INTERUPT
                                 Timer0OVF: ; interrupt subroutine to Timer0
                                 	
000544 930f
000545 931f
000546 932f
000547 b70f
000548 930f
000549 93df
00054a 93cf
00054b 939f
00054c 938f                      	pushStack
                                 	; Load the value of the temporary counter.
00054d 9180 0204                 	lds r24, TempCounter
00054f 9190 0205                 	lds r25, TempCounter+1
000551 9601                      	adiw r25:r24, 1 ; Increase the temporary counter by one.
                                 
000552 3a81                      	cpi r24, low(1953) ; Check if (r25:r24) = 7812
000553 e007                      	ldi temp, high(1953) ; 7812 = 10^6/128
000554 0790                      	cpc r25, temp
000555 f479                      	brne NotSecond //not 0.25 seconds
                                 
                                 	////////sound stuff
000556 9100 020b                 	lds temp, sound
000558 3001                      	cpi temp, 1
000559 f418                      	brsh outputSound 
00055a e020                      	ldi temp2, 0b00000000
00055b b925                      	out PORTB, temp2  //Set no sound
                                 	
                                 	
00055c c00d                      	rjmp returnFlag
                                 
                                 	outputSound:
00055d e820                      		ldi temp2, 0b10000000
00055e b925                      		out PORTB, temp2
00055f 9120 020b                 		lds temp2, sound
000561 952a                      		dec temp2
000562 9320 020b                 		sts sound, temp2
                                 
                                 
                                 	//////////////
                                 
000564 c005                      	rjmp returnflag
                                 NotSecond:
                                 	; Store the new value of the temporary counter.
000565 9380 0204                 	sts TempCounter, r24
000567 9390 0205                 	sts TempCounter+1, r25
000569 c054                      	rjmp epilogue
                                 
                                 	// Execute every 0.25 sec
                                 	returnFlag:
00056a 9120 0210                 		lds temp2, coinReturnTime // check if we need to return coins
00056c 3020                      		cpi temp2, 0
00056d f091                      		breq timer1flag 
                                 		//out portc, temp2
00056e 7021                      		andi temp2, 0b00000001
                                 		//out portc, temp2
00056f 3020                      		cpi temp2,0 // and so we can check if number is odd or even
000570 f429                      		brne odd
000571 930f
000572 e100
000573 b90e
000574 910f                      		startmotor
000575 c004                      		rjmp reducecoins
                                 		odd: 
000576 930f
000577 e000
000578 b90e
000579 910f                      		stopmotor
                                 
                                 		reducecoins:
00057a 9120 0210                 		lds temp2, coinReturnTime 
00057c 952a                      		dec temp2                   //reduce coin number and store back
00057d 9320 0210                 		sts coinReturnTime, temp2
00057f c038                      		rjmp newQsecond
                                 
                                 	timer1flag:
000580 9100 0200
000582 3001                      		checkIfMenu 1
000583 f441                      		brne timer6flag
000584 9100 0206                 		lds temp, timer1
000586 3000                      		cpi temp, 0
000587 f161                      		breq callSelectScreen 
000588 950a                      		dec temp
000589 9300 0206                 		sts timer1, temp
00058b c02c                      		rjmp newQsecond
                                 	timer6flag:
00058c 9100 0200
00058e 3002                      		checkIfMenu 2		;admin mode can only be entered in menu 2
00058f f461                      		brne timer3flag		;ELSE move on
                                 
000590 9100 020a                 		lds temp, prevNum   ;only enter loop if '*' is pressed
000592 320a                      		cpi temp, '*'
000593 f441                      		brne timer3flag
                                 
000594 9100 0208                 		lds temp, timer6       ;load timer 6 = 20 = 5secs
                                 
000596 3000                      		cpi temp, 0			   ;when timer runs down to 0, decrement
000597 f0f1                      		breq callAdminMode 
                                 		;out portc, temp ; DEBUG DISPLAY TIMER6, (IT WORKS)
000598 950a                      		dec temp
000599 9300 0208                 		sts timer6, temp
00059b c01c                      		rjmp newQsecond
                                 
                                 	timer3flag:
00059c 9100 0200
00059e 3003                      		checkIfMenu 3 ;check if in out of stock screen
00059f f4f1                      		brne epilogue
0005a0 9100 0207                 		lds temp, timer3
                                 		;out portc, temp
0005a2 3000                      		cpi temp, 0
0005a3 f081                      		breq callSelectScreen ;change later
                                 	
                                 		//FLASH LEDS
0005a4 2f20                      		mov temp2, temp //load time into temp
0005a5 7021                      		andi temp2, 0b00000001 //and to get either a 1 or 0 in the last bit
0005a6 3020                      		cpi temp2, 0 //0 = even, 1 = odd
0005a7 f441                      		brne continue //If odd skip
0005a8 ef1f                      		ser temp1
0005a9 9120 0213                 		lds temp2, pattern
0005ab 2721                      		eor temp2, temp1 //Invert pattern
0005ac 9320 0213                 		sts pattern, temp2
0005ae b928                      		out portc, temp2
0005af bb24                      		out portg, temp2
                                 
                                 		continue:
0005b0 950a                      		dec temp
                                 		;out portc, temp
0005b1 9300 0207                 		sts timer3, temp
0005b3 c004                      		rjmp newQsecond
                                 	
                                 	callSelectScreen:
0005b4 dd64                      		rcall selectScreen
0005b5 c008                      		rjmp epilogue
                                 
                                 	callAdminMode:
0005b6 ded2                      		rcall enterAdminMode
0005b7 c006                      		rjmp epilogue
                                 
                                 newQsecond: ;starts new quarter 
0005b8 e0c4
0005b9 e0d2
0005ba 2700
0005bb 9309
0005bc 8308                      	clear TempCounter ; Reset the temporary counter.
0005bd c000                      	rjmp epilogue
                                 
                                 epilogue:
0005be 918f
0005bf 919f
0005c0 91cf
0005c1 91df
0005c2 910f
0005c3 bf0f
0005c4 912f
0005c5 911f
0005c6 910f                      	popStack
0005c7 9518                      	reti ; Return from the interrupt.
                                 /*
                                 // PUSH BUTTON INTERUPTS :)
                                 EXT_INT0: ;Right Button
                                 	pushStack
                                 	clr temp
                                 	out PORTC, temp
                                 	out PORTG, temp
                                 	
                                 	checkIfMenu 6
                                 	breq incStock
                                 
                                 	checkIfMenu 3  ;if menu = 3, go back to select screen 
                                 	brne endBridge0
                                 	rcall selectScreen
                                 	rjmp ENT_INT1
                                 
                                 //CHECK FOR LATER
                                 endBridge0:
                                 	jmp END_INT0
                                 	rcall selectScreen
                                 	rjmp END_INT1
                                 END_INT0:
                                 	popStack
                                 	reti
                                 incStock:
                                 	increaseStock
                                 	updateAdminScreen
                                 */
                                 EXT_INT0: ;Right Button
0005c8 930f
0005c9 931f
0005ca 932f
0005cb b70f
0005cc 930f
0005cd 93df
0005ce 93cf
0005cf 939f
0005d0 938f                      	pushStack
                                 	
0005d1 2700                      	clr temp
0005d2 b908                      	out PORTC, temp
0005d3 bb04                      	out PORTG, temp
                                 	
0005d4 9100 0200
0005d6 3006                      	checkIfMenu 6
0005d7 f049                      	breq incStock
                                 	
0005d8 9100 0200
0005da 3003                      	checkIfMenu 3  ;if menu = 3, go back to select screen 
0005db f419                      	brne bridgeENDINT0
0005dc dd3c                      	rcall selectScreen
0005dd 940c 071b                 	jmp END_INT0
                                 bridgeENDINT0:
0005df 940c 071b                 	jmp END_INT0
                                 incStock:
0005e1 930f
0005e2 931f
0005e3 932f
0005e4 b70f
0005e5 930f
0005e6 e308
0005e7 d29b
0005e8 d2aa
0005e9 d2c3
0005ea e308
0005eb d297
0005ec d2a6
0005ed d2b6
0005ee e308
0005ef d293
0005f0 d2a2
0005f1 e308
0005f2 d290
0005f3 d29f
0005f4 e008
0005f5 d28d
0005f6 d29c
0005f7 e001
0005f8 d28a
0005f9 d299
0005fa e006
0005fb d287
0005fc d296
0005fd e00c
0005fe d284
0005ff d293
000600 e401
000601 d288
000602 d290
000603 e604
000604 d285
000605 d28d
000606 e60d
000607 d282
000608 d28a
000609 e609
00060a d27f
00060b d287
00060c e60e
00060d d27c
00060e d284
00060f e200
000610 d279
000611 d281
000612 e40d
000613 d276
000614 d27e
000615 e60f
000616 d273
000617 d27b
000618 e604
000619 d270
00061a d278
00061b e605
00061c d26d
00061d d275
00061e e200
00061f d26a
000620 d272
000621 9100 0209
000623 5d00
000624 2f00
000625 d264
000626 d26c
000627 ea08
000628 d25a
000629 d269
00062a 9100 0211
00062c 5d00
00062d 2f00
00062e d25b
00062f d263
000630 e200
000631 d258
000632 d260
000633 e200
000634 d255
000635 d25d
000636 e200
000637 d252
000638 d25a
000639 e200
00063a d24f
00063b d257
00063c e200
00063d d24c
00063e d254
00063f e200
000640 d249
000641 d251
000642 e200
000643 d246
000644 d24e
000645 e204
000646 2f00
000647 d242
000648 d24a
000649 9100 0212
00064b 5d00
00064c 2f00
00064d d23c
00064e d244
00064f 930f
000650 931f
000651 932f
000652 b70f
000653 930f
000654 9100 0211
000656 3009
000657 f038
000658 e011
000659 bb14
00065a 300a
00065b f028
00065c e013
00065d bb14
00065e c002
00065f 2711
000660 bb14
000661 2711
000662 3000
000663 f031
000664 0f11
000665 5f1f
000666 950a
000667 3000
000668 f009
000669 cffa
00066a b918
00066b 910f
00066c bf0f
00066d 912f
00066e 911f
00066f 910f
000670 910f
000671 bf0f
000672 912f
000673 911f
000674 910f                      	updateAdminScreen
000675 930f
000676 931f
000677 932f
000678 b70f
000679 930f
00067a 9120 0211
00067c 302a
00067d f021
00067e 9523
00067f 9320 0211
000681 8328
000682 910f
000683 bf0f
000684 912f
000685 911f
000686 910f                      	increaseStock
000687 930f
000688 931f
000689 932f
00068a b70f
00068b 930f
00068c e308
00068d d1f5
00068e d204
00068f d21d
000690 e308
000691 d1f1
000692 d200
000693 d210
000694 e308
000695 d1ed
000696 d1fc
000697 e308
000698 d1ea
000699 d1f9
00069a e008
00069b d1e7
00069c d1f6
00069d e001
00069e d1e4
00069f d1f3
0006a0 e006
0006a1 d1e1
0006a2 d1f0
0006a3 e00c
0006a4 d1de
0006a5 d1ed
0006a6 e401
0006a7 d1e2
0006a8 d1ea
0006a9 e604
0006aa d1df
0006ab d1e7
0006ac e60d
0006ad d1dc
0006ae d1e4
0006af e609
0006b0 d1d9
0006b1 d1e1
0006b2 e60e
0006b3 d1d6
0006b4 d1de
0006b5 e200
0006b6 d1d3
0006b7 d1db
0006b8 e40d
0006b9 d1d0
0006ba d1d8
0006bb e60f
0006bc d1cd
0006bd d1d5
0006be e604
0006bf d1ca
0006c0 d1d2
0006c1 e605
0006c2 d1c7
0006c3 d1cf
0006c4 e200
0006c5 d1c4
0006c6 d1cc
0006c7 9100 0209
0006c9 5d00
0006ca 2f00
0006cb d1be
0006cc d1c6
0006cd ea08
0006ce d1b4
0006cf d1c3
0006d0 9100 0211
0006d2 5d00
0006d3 2f00
0006d4 d1b5
0006d5 d1bd
0006d6 e200
0006d7 d1b2
0006d8 d1ba
0006d9 e200
0006da d1af
0006db d1b7
0006dc e200
0006dd d1ac
0006de d1b4
0006df e200
0006e0 d1a9
0006e1 d1b1
0006e2 e200
0006e3 d1a6
0006e4 d1ae
0006e5 e200
0006e6 d1a3
0006e7 d1ab
0006e8 e200
0006e9 d1a0
0006ea d1a8
0006eb e204
0006ec 2f00
0006ed d19c
0006ee d1a4
0006ef 9100 0212
0006f1 5d00
0006f2 2f00
0006f3 d196
0006f4 d19e
0006f5 930f
0006f6 931f
0006f7 932f
0006f8 b70f
0006f9 930f
0006fa 9100 0211
0006fc 3009
0006fd f038
0006fe e011
0006ff bb14
000700 300a
000701 f028
000702 e013
000703 bb14
000704 c002
000705 2711
000706 bb14
000707 2711
000708 3000
000709 f031
00070a 0f11
00070b 5f1f
00070c 950a
00070d 3000
00070e f009
00070f cffa
000710 b918
000711 910f
000712 bf0f
000713 912f
000714 911f
000715 910f
000716 910f
000717 bf0f
000718 912f
000719 911f
00071a 910f                      	updateAdminScreen
                                 END_INT0:
00071b 918f
00071c 919f
00071d 91cf
00071e 91df
00071f 910f
000720 bf0f
000721 912f
000722 911f
000723 910f                      	popStack
000724 9518                      	reti
                                 
                                 
                                 EXT_INT1: ;Left Button
000725 930f
000726 931f
000727 932f
000728 b70f
000729 930f
00072a 93df
00072b 93cf
00072c 939f
00072d 938f                      	pushStack
                                 	
00072e 2700                      	clr temp
00072f b908                      	out PORTC, temp
000730 bb04                      	out PORTG, temp
                                 	
000731 9100 0200
000733 3006                      	checkIfMenu 6
000734 f049                      	breq decStock
                                 	
000735 9100 0200
000737 3003                      	checkIfMenu 3  ;if menu = 3, go back to select screen 
000738 f419                      	brne bridgeENDINT1
000739 dbdf                      	rcall selectScreen
00073a 940c 0878                 	jmp END_INT1
                                 bridgeENDINT1:
00073c 940c 0878                 	jmp END_INT1
                                 decStock:
00073e 930f
00073f 931f
000740 932f
000741 b70f
000742 930f
000743 e308
000744 d13e
000745 d14d
000746 d166
000747 e308
000748 d13a
000749 d149
00074a d159
00074b e308
00074c d136
00074d d145
00074e e308
00074f d133
000750 d142
000751 e008
000752 d130
000753 d13f
000754 e001
000755 d12d
000756 d13c
000757 e006
000758 d12a
000759 d139
00075a e00c
00075b d127
00075c d136
00075d e401
00075e d12b
00075f d133
000760 e604
000761 d128
000762 d130
000763 e60d
000764 d125
000765 d12d
000766 e609
000767 d122
000768 d12a
000769 e60e
00076a d11f
00076b d127
00076c e200
00076d d11c
00076e d124
00076f e40d
000770 d119
000771 d121
000772 e60f
000773 d116
000774 d11e
000775 e604
000776 d113
000777 d11b
000778 e605
000779 d110
00077a d118
00077b e200
00077c d10d
00077d d115
00077e 9100 0209
000780 5d00
000781 2f00
000782 d107
000783 d10f
000784 ea08
000785 d0fd
000786 d10c
000787 9100 0211
000789 5d00
00078a 2f00
00078b d0fe
00078c d106
00078d e200
00078e d0fb
00078f d103
000790 e200
000791 d0f8
000792 d100
000793 e200
000794 d0f5
000795 d0fd
000796 e200
000797 d0f2
000798 d0fa
000799 e200
00079a d0ef
00079b d0f7
00079c e200
00079d d0ec
00079e d0f4
00079f e200
0007a0 d0e9
0007a1 d0f1
0007a2 e204
0007a3 2f00
0007a4 d0e5
0007a5 d0ed
0007a6 9100 0212
0007a8 5d00
0007a9 2f00
0007aa d0df
0007ab d0e7
0007ac 930f
0007ad 931f
0007ae 932f
0007af b70f
0007b0 930f
0007b1 9100 0211
0007b3 3009
0007b4 f038
0007b5 e011
0007b6 bb14
0007b7 300a
0007b8 f028
0007b9 e013
0007ba bb14
0007bb c002
0007bc 2711
0007bd bb14
0007be 2711
0007bf 3000
0007c0 f031
0007c1 0f11
0007c2 5f1f
0007c3 950a
0007c4 3000
0007c5 f009
0007c6 cffa
0007c7 b918
0007c8 910f
0007c9 bf0f
0007ca 912f
0007cb 911f
0007cc 910f
0007cd 910f
0007ce bf0f
0007cf 912f
0007d0 911f
0007d1 910f                      	updateAdminScreen
0007d2 930f
0007d3 931f
0007d4 932f
0007d5 b70f
0007d6 930f
0007d7 9120 0211
0007d9 3020
0007da f021
0007db 952a
0007dc 9320 0211
0007de 8328
0007df 910f
0007e0 bf0f
0007e1 912f
0007e2 911f
0007e3 910f                      	decreaseStock
0007e4 930f
0007e5 931f
0007e6 932f
0007e7 b70f
0007e8 930f
0007e9 e308
0007ea d098
0007eb d0a7
0007ec d0c0
0007ed e308
0007ee d094
0007ef d0a3
0007f0 d0b3
0007f1 e308
0007f2 d090
0007f3 d09f
0007f4 e308
0007f5 d08d
0007f6 d09c
0007f7 e008
0007f8 d08a
0007f9 d099
0007fa e001
0007fb d087
0007fc d096
0007fd e006
0007fe d084
0007ff d093
000800 e00c
000801 d081
000802 d090
000803 e401
000804 d085
000805 d08d
000806 e604
000807 d082
000808 d08a
000809 e60d
00080a d07f
00080b d087
00080c e609
00080d d07c
00080e d084
00080f e60e
000810 d079
000811 d081
000812 e200
000813 d076
000814 d07e
000815 e40d
000816 d073
000817 d07b
000818 e60f
000819 d070
00081a d078
00081b e604
00081c d06d
00081d d075
00081e e605
00081f d06a
000820 d072
000821 e200
000822 d067
000823 d06f
000824 9100 0209
000826 5d00
000827 2f00
000828 d061
000829 d069
00082a ea08
00082b d057
00082c d066
00082d 9100 0211
00082f 5d00
000830 2f00
000831 d058
000832 d060
000833 e200
000834 d055
000835 d05d
000836 e200
000837 d052
000838 d05a
000839 e200
00083a d04f
00083b d057
00083c e200
00083d d04c
00083e d054
00083f e200
000840 d049
000841 d051
000842 e200
000843 d046
000844 d04e
000845 e200
000846 d043
000847 d04b
000848 e204
000849 2f00
00084a d03f
00084b d047
00084c 9100 0212
00084e 5d00
00084f 2f00
000850 d039
000851 d041
000852 930f
000853 931f
000854 932f
000855 b70f
000856 930f
000857 9100 0211
000859 3009
00085a f038
00085b e011
00085c bb14
00085d 300a
00085e f028
00085f e013
000860 bb14
000861 c002
000862 2711
000863 bb14
000864 2711
000865 3000
000866 f031
000867 0f11
000868 5f1f
000869 950a
00086a 3000
00086b f009
00086c cffa
00086d b918
00086e 910f
00086f bf0f
000870 912f
000871 911f
000872 910f
000873 910f
000874 bf0f
000875 912f
000876 911f
000877 910f                      	updateAdminScreen
                                 END_INT1:
000878 918f
000879 919f
00087a 91cf
00087b 91df
00087c 910f
00087d bf0f
00087e 912f
00087f 911f
000880 910f                      	popStack
000881 9518                      	reti
                                 
                                 
                                 
                                 halt:
000882 cfff                      	rjmp halt
                                 
                                 	
                                 .include "lcd.asm"
                                 
                                 
                                 
                                 .equ LCD_RS = 7
                                 .equ LCD_E = 6
                                 .equ LCD_RW = 5
                                 .equ LCD_BE = 4
                                 
                                 .macro lcd_set
                                 	sbi PORTA, @0
                                 .endmacro
                                 .macro lcd_clr
                                 	cbi PORTA, @0
                                 .endmacro
                                 ;
                                 ; Send a command to the LCD (r16)
                                 ;
                                 
                                 lcd_command:
000883 bb01                      	out PORTF, r16
000884 d01f                      	rcall sleep_1ms
000885 9a16                      	lcd_set LCD_E
000886 d01d                      	rcall sleep_1ms
000887 9816                      	lcd_clr LCD_E
000888 d01b                      	rcall sleep_1ms
000889 9508                      	ret
                                 
                                 lcd_data:
00088a bb01                      	out PORTF, r16
00088b 9a17                      	lcd_set LCD_RS
00088c d017                      	rcall sleep_1ms
00088d 9a16                      	lcd_set LCD_E
00088e d015                      	rcall sleep_1ms
00088f 9816                      	lcd_clr LCD_E
000890 d013                      	rcall sleep_1ms
000891 9817                      	lcd_clr LCD_RS
000892 9508                      	ret
                                 
                                 lcd_wait:
000893 930f                      	push r16
000894 2700                      	clr r16
000895 bb00                      	out DDRF, r16
000896 bb01                      	out PORTF, r16
000897 9a15                      	lcd_set LCD_RW
                                 lcd_wait_loop:
000898 d00b                      	rcall sleep_1ms
000899 9a16                      	lcd_set LCD_E
00089a d009                      	rcall sleep_1ms
00089b b10f                      	in r16, PINF
00089c 9816                      	lcd_clr LCD_E
00089d fd07                      	sbrc r16, 7
00089e cff9                      	rjmp lcd_wait_loop
00089f 9815                      	lcd_clr LCD_RW
0008a0 ef0f                      	ser r16
0008a1 bb00                      	out DDRF, r16
0008a2 910f                      	pop r16
0008a3 9508                      	ret
                                 
                                 .equ F_CPU = 16000000
                                 .equ DELAY_1MS = F_CPU / 4 / 1000 - 4
                                 ; 4 cycles per iteration - setup/call-return overhead
                                 
                                 sleep_1ms:
0008a4 938f                      	push r24
0008a5 939f                      	push r25
0008a6 e09f                      	ldi r25, high(DELAY_1MS)
0008a7 e98c                      	ldi r24, low(DELAY_1MS)
                                 delayloop_1ms:
0008a8 9701                      	sbiw r25:r24, 1
0008a9 f7f1                      	brne delayloop_1ms
0008aa 919f                      	pop r25
0008ab 918f                      	pop r24
0008ac 9508                      	ret
                                 
                                 sleep_5ms:
0008ad dff6                      	rcall sleep_1ms
0008ae dff5                      	rcall sleep_1ms
0008af dff4                      	rcall sleep_1ms
0008b0 dff3                      	rcall sleep_1ms
0008b1 dff2                      	rcall sleep_1ms
0008b2 9508                      	ret
                                 
                                 sleep_500ms:
0008b3 930f                      	push temp
0008b4 e604                      	ldi temp, 100
                                 
                                 	loop:
0008b5 dff7                      	rcall sleep_5ms
0008b6 950a                      	dec temp
0008b7 3000                      	cpi temp, 0
0008b8 f7e1                      	brne loop
                                 
0008b9 910f                      	pop temp
0008ba 9508                      	ret
                                 
                                 sleep_25ms:
0008bb dff1                      	rcall sleep_5ms
0008bc dff0                      	rcall sleep_5ms
0008bd dfef                      	rcall sleep_5ms
0008be dfee                      	rcall sleep_5ms
0008bf dfed                      	rcall sleep_5ms
0008c0 dfec                      	rcall sleep_5ms
0008c1 dfeb                      	rcall sleep_5ms
0008c2 dfea                      	rcall sleep_5ms
0008c3 dfe9                      	rcall sleep_5ms
0008c4 dfe8                      	rcall sleep_5ms
0008c5 dfe7                      	rcall sleep_5ms
0008c6 dfe6                      	rcall sleep_5ms
0008c7 dfe5                      	rcall sleep_5ms
0008c8 dfe4                      	rcall sleep_5ms
0008c9 dfe3                      	rcall sleep_5ms
0008ca dfe2                      	rcall sleep_5ms
0008cb dfe1                      	rcall sleep_5ms
0008cc dfe0                      	rcall sleep_5ms
0008cd dfdf                      	rcall sleep_5ms
0008ce dfde                      	rcall sleep_5ms
0008cf 9508                      


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega2560" register use summary:
x  :   0 y  :  42 z  :   0 r0 :   0 r1 :   0 r2 :   0 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   0 r14:   0 r15:   0 r16: 841 r17: 162 r18: 111 r19:   7 r20:   7 
r21:   3 r22:   3 r23:  19 r24:  16 r25:  16 r26:   0 r27:   0 r28:  15 
r29:  15 r30:   3 r31:   3 
Registers used: 15 out of 35 (42.9%)

"ATmega2560" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   0 add   :   3 adiw  :   1 and   :   1 
andi  :   3 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   0 brcs  :   0 break :   0 breq  :  51 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  12 brlt  :   1 brmi  :   0 
brne  :  21 brpl  :   0 brsh  :   1 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   5 cbr   :   0 
clc   :   0 clh   :   0 cli   :   0 cln   :   0 clr   :  28 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   0 cp    :   3 cpc   :   3 
cpi   :  80 cpse  :   0 dec   :  23 eicall:   0 eijmp :   0 elpm  :   0 
eor   :   1 fmul  :   0 fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   0 
in    :  26 inc   :   9 jmp   :  25 ld    :   9 ldd   :   3 ldi   : 390 
lds   :  74 lpm   :   0 lsl   :  14 lsr   :   0 mov   :  31 movw  :   0 
mul   :   0 muls  :   0 mulsu :   0 neg   :   0 nop   :   0 or    :   0 
ori   :   2 out   :  90 pop   : 127 push  : 127 rcall : 688 ret   :  13 
reti  :   4 rjmp  :  42 rol   :   0 ror   :   0 sbc   :   0 sbci  :   0 
sbi   :   5 sbic  :   0 sbis  :   0 sbiw  :   1 sbr   :   0 sbrc  :   1 
sbrs  :   0 sec   :   0 seh   :   0 sei   :   1 sen   :   0 ser   :   6 
ses   :   0 set   :   0 sev   :   0 sez   :   0 sleep :   0 spm   :   0 
st    :  28 std   :   2 sts   :  62 sub   :   1 subi  :  27 swap  :   0 
tst   :   0 wdr   :   0 
Instructions used: 43 out of 116 (37.1%)

"ATmega2560" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0011a0   4412      0   4412  262144   1.7%
[.dseg] 0x000200 0x000226      0     38     38    8192   0.5%
[.eseg] 0x000000 0x000000      0      0      0    4096   0.0%

Assembly complete, 0 errors, 0 warnings
