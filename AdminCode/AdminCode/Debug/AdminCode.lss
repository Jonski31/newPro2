
AVRASM ver. 2.2.6  c:\users\kurt\Documents\Atmel Studio\7.0\AdminCode\AdminCode\main.asm Fri Jun 02 00:58:47 2017

[builtin](2): Including file 'C:/Program Files\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.2.132\avrasm\inc\m2560def.inc'
c:\users\kurt\Documents\Atmel Studio\7.0\AdminCode\AdminCode\main.asm(8): Including file 'C:/Program Files\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.2.132\avrasm\inc\m2560def.inc'
c:\users\kurt\Documents\Atmel Studio\7.0\AdminCode\AdminCode\main.asm(29): Including file 'c:\users\kurt\Documents\Atmel Studio\7.0\AdminCode\AdminCode\macros.asm'
c:\users\kurt\Documents\Atmel Studio\7.0\AdminCode\AdminCode\main.asm(72): Including file 'c:\users\kurt\Documents\Atmel Studio\7.0\AdminCode\AdminCode\keypad.asm'
c:\users\kurt\Documents\Atmel Studio\7.0\AdminCode\AdminCode\main.asm(73): Including file 'c:\users\kurt\Documents\Atmel Studio\7.0\AdminCode\AdminCode\inventory.asm'
c:\users\kurt\Documents\Atmel Studio\7.0\AdminCode\AdminCode\main.asm(486): Including file 'c:\users\kurt\Documents\Atmel Studio\7.0\AdminCode\AdminCode\lcd.asm'
[builtin](2): Including file 'C:/Program Files\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.2.132\avrasm\inc\m2560def.inc'
c:\users\kurt\Documents\Atmel Studio\7.0\AdminCode\AdminCode\main.asm(8): Including file 'C:/Program Files\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.2.132\avrasm\inc\m2560def.inc'
c:\users\kurt\Documents\Atmel Studio\7.0\AdminCode\AdminCode\main.asm(29): Including file 'c:\users\kurt\Documents\Atmel Studio\7.0\AdminCode\AdminCode\macros.asm'
c:\users\kurt\Documents\Atmel Studio\7.0\AdminCode\AdminCode\main.asm(72): Including file 'c:\users\kurt\Documents\Atmel Studio\7.0\AdminCode\AdminCode\keypad.asm'
c:\users\kurt\Documents\Atmel Studio\7.0\AdminCode\AdminCode\main.asm(73): Including file 'c:\users\kurt\Documents\Atmel Studio\7.0\AdminCode\AdminCode\inventory.asm'
c:\users\kurt\Documents\Atmel Studio\7.0\AdminCode\AdminCode\main.asm(486): Including file 'c:\users\kurt\Documents\Atmel Studio\7.0\AdminCode\AdminCode\lcd.asm'
                                 
                                 ;
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega2560.xml **********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m2560def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega2560
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega2560
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M2560DEF_INC_
                                 #define _M2560DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega2560
                                 #pragma AVRPART ADMIN PART_NAME ATmega2560
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x98
                                 .equ	SIGNATURE_002	= 0x01
                                 
                                 #pragma AVRPART CORE CORE_VERSION V3
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	UDR3	= 0x136	; MEMORY MAPPED
                                 .equ	UBRR3L	= 0x134	; MEMORY MAPPED
                                 .equ	UBRR3H	= 0x135	; MEMORY MAPPED
                                 .equ	UCSR3C	= 0x132	; MEMORY MAPPED
                                 .equ	UCSR3B	= 0x131	; MEMORY MAPPED
                                 .equ	UCSR3A	= 0x130	; MEMORY MAPPED
                                 .equ	OCR5CL	= 0x12c	; MEMORY MAPPED
                                 .equ	OCR5CH	= 0x12d	; MEMORY MAPPED
                                 .equ	OCR5BL	= 0x12a	; MEMORY MAPPED
                                 .equ	OCR5BH	= 0x12b	; MEMORY MAPPED
                                 .equ	OCR5AL	= 0x128	; MEMORY MAPPED
                                 .equ	OCR5AH	= 0x129	; MEMORY MAPPED
                                 .equ	ICR5H	= 0x127	; MEMORY MAPPED
                                 .equ	ICR5L	= 0x126	; MEMORY MAPPED
                                 .equ	TCNT5L	= 0x124	; MEMORY MAPPED
                                 .equ	TCNT5H	= 0x125	; MEMORY MAPPED
                                 .equ	TCCR5C	= 0x122	; MEMORY MAPPED
                                 .equ	TCCR5B	= 0x121	; MEMORY MAPPED
                                 .equ	TCCR5A	= 0x120	; MEMORY MAPPED
                                 .equ	PORTL	= 0x10b	; MEMORY MAPPED
                                 .equ	DDRL	= 0x10a	; MEMORY MAPPED
                                 .equ	PINL	= 0x109	; MEMORY MAPPED
                                 .equ	PORTK	= 0x108	; MEMORY MAPPED
                                 .equ	DDRK	= 0x107	; MEMORY MAPPED
                                 .equ	PINK	= 0x106	; MEMORY MAPPED
                                 .equ	PORTJ	= 0x105	; MEMORY MAPPED
                                 .equ	DDRJ	= 0x104	; MEMORY MAPPED
                                 .equ	PINJ	= 0x103	; MEMORY MAPPED
                                 .equ	PORTH	= 0x102	; MEMORY MAPPED
                                 .equ	DDRH	= 0x101	; MEMORY MAPPED
                                 .equ	PINH	= 0x100	; MEMORY MAPPED
                                 .equ	UDR2	= 0xd6	; MEMORY MAPPED
                                 .equ	UBRR2L	= 0xd4	; MEMORY MAPPED
                                 .equ	UBRR2H	= 0xd5	; MEMORY MAPPED
                                 .equ	UCSR2C	= 0xd2	; MEMORY MAPPED
                                 .equ	UCSR2B	= 0xd1	; MEMORY MAPPED
                                 .equ	UCSR2A	= 0xd0	; MEMORY MAPPED
                                 .equ	UDR1	= 0xce	; MEMORY MAPPED
                                 .equ	UBRR1L	= 0xcc	; MEMORY MAPPED
                                 .equ	UBRR1H	= 0xcd	; MEMORY MAPPED
                                 .equ	UCSR1C	= 0xca	; MEMORY MAPPED
                                 .equ	UCSR1B	= 0xc9	; MEMORY MAPPED
                                 .equ	UCSR1A	= 0xc8	; MEMORY MAPPED
                                 .equ	UDR0	= 0xc6	; MEMORY MAPPED
                                 .equ	UBRR0L	= 0xc4	; MEMORY MAPPED
                                 .equ	UBRR0H	= 0xc5	; MEMORY MAPPED
                                 .equ	UCSR0C	= 0xc2	; MEMORY MAPPED
                                 .equ	UCSR0B	= 0xc1	; MEMORY MAPPED
                                 .equ	UCSR0A	= 0xc0	; MEMORY MAPPED
                                 .equ	TWAMR	= 0xbd	; MEMORY MAPPED
                                 .equ	TWCR	= 0xbc	; MEMORY MAPPED
                                 .equ	TWDR	= 0xbb	; MEMORY MAPPED
                                 .equ	TWAR	= 0xba	; MEMORY MAPPED
                                 .equ	TWSR	= 0xb9	; MEMORY MAPPED
                                 .equ	TWBR	= 0xb8	; MEMORY MAPPED
                                 .equ	ASSR	= 0xb6	; MEMORY MAPPED
                                 .equ	OCR2B	= 0xb4	; MEMORY MAPPED
                                 .equ	OCR2A	= 0xb3	; MEMORY MAPPED
                                 .equ	TCNT2	= 0xb2	; MEMORY MAPPED
                                 .equ	TCCR2B	= 0xb1	; MEMORY MAPPED
                                 .equ	TCCR2A	= 0xb0	; MEMORY MAPPED
                                 .equ	OCR4CL	= 0xac	; MEMORY MAPPED
                                 .equ	OCR4CH	= 0xad	; MEMORY MAPPED
                                 .equ	OCR4BL	= 0xaa	; MEMORY MAPPED
                                 .equ	OCR4BH	= 0xab	; MEMORY MAPPED
                                 .equ	OCR4AL	= 0xa8	; MEMORY MAPPED
                                 .equ	OCR4AH	= 0xa9	; MEMORY MAPPED
                                 .equ	ICR4L	= 0xa6	; MEMORY MAPPED
                                 .equ	ICR4H	= 0xa7	; MEMORY MAPPED
                                 .equ	TCNT4L	= 0xa4	; MEMORY MAPPED
                                 .equ	TCNT4H	= 0xa5	; MEMORY MAPPED
                                 .equ	TCCR4C	= 0xa2	; MEMORY MAPPED
                                 .equ	TCCR4B	= 0xa1	; MEMORY MAPPED
                                 .equ	TCCR4A	= 0xa0	; MEMORY MAPPED
                                 .equ	OCR3CL	= 0x9c	; MEMORY MAPPED
                                 .equ	OCR3CH	= 0x9d	; MEMORY MAPPED
                                 .equ	OCR3BL	= 0x9a	; MEMORY MAPPED
                                 .equ	OCR3BH	= 0x9b	; MEMORY MAPPED
                                 .equ	OCR3AL	= 0x98	; MEMORY MAPPED
                                 .equ	OCR3AH	= 0x99	; MEMORY MAPPED
                                 .equ	ICR3L	= 0x96	; MEMORY MAPPED
                                 .equ	ICR3H	= 0x97	; MEMORY MAPPED
                                 .equ	TCNT3L	= 0x94	; MEMORY MAPPED
                                 .equ	TCNT3H	= 0x95	; MEMORY MAPPED
                                 .equ	TCCR3C	= 0x92	; MEMORY MAPPED
                                 .equ	TCCR3B	= 0x91	; MEMORY MAPPED
                                 .equ	TCCR3A	= 0x90	; MEMORY MAPPED
                                 .equ	OCR1CL	= 0x8c	; MEMORY MAPPED
                                 .equ	OCR1CH	= 0x8d	; MEMORY MAPPED
                                 .equ	OCR1BL	= 0x8a	; MEMORY MAPPED
                                 .equ	OCR1BH	= 0x8b	; MEMORY MAPPED
                                 .equ	OCR1AL	= 0x88	; MEMORY MAPPED
                                 .equ	OCR1AH	= 0x89	; MEMORY MAPPED
                                 .equ	ICR1L	= 0x86	; MEMORY MAPPED
                                 .equ	ICR1H	= 0x87	; MEMORY MAPPED
                                 .equ	TCNT1L	= 0x84	; MEMORY MAPPED
                                 .equ	TCNT1H	= 0x85	; MEMORY MAPPED
                                 .equ	TCCR1C	= 0x82	; MEMORY MAPPED
                                 .equ	TCCR1B	= 0x81	; MEMORY MAPPED
                                 .equ	TCCR1A	= 0x80	; MEMORY MAPPED
                                 .equ	DIDR1	= 0x7f	; MEMORY MAPPED
                                 .equ	DIDR0	= 0x7e	; MEMORY MAPPED
                                 .equ	DIDR2	= 0x7d	; MEMORY MAPPED
                                 .equ	ADMUX	= 0x7c	; MEMORY MAPPED
                                 .equ	ADCSRB	= 0x7b	; MEMORY MAPPED
                                 .equ	ADCSRA	= 0x7a	; MEMORY MAPPED
                                 .equ	ADCH	= 0x79	; MEMORY MAPPED
                                 .equ	ADCL	= 0x78	; MEMORY MAPPED
                                 .equ	XMCRB	= 0x75	; MEMORY MAPPED
                                 .equ	XMCRA	= 0x74	; MEMORY MAPPED
                                 .equ	TIMSK5	= 0x73	; MEMORY MAPPED
                                 .equ	TIMSK4	= 0x72	; MEMORY MAPPED
                                 .equ	TIMSK3	= 0x71	; MEMORY MAPPED
                                 .equ	TIMSK2	= 0x70	; MEMORY MAPPED
                                 .equ	TIMSK1	= 0x6f	; MEMORY MAPPED
                                 .equ	TIMSK0	= 0x6e	; MEMORY MAPPED
                                 .equ	PCMSK2	= 0x6d	; MEMORY MAPPED
                                 .equ	PCMSK1	= 0x6c	; MEMORY MAPPED
                                 .equ	PCMSK0	= 0x6b	; MEMORY MAPPED
                                 .equ	EICRB	= 0x6a	; MEMORY MAPPED
                                 .equ	EICRA	= 0x69	; MEMORY MAPPED
                                 .equ	PCICR	= 0x68	; MEMORY MAPPED
                                 .equ	OSCCAL	= 0x66	; MEMORY MAPPED
                                 .equ	PRR1	= 0x65	; MEMORY MAPPED
                                 .equ	PRR0	= 0x64	; MEMORY MAPPED
                                 .equ	CLKPR	= 0x61	; MEMORY MAPPED
                                 .equ	WDTCSR	= 0x60	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	EIND	= 0x3c
                                 .equ	RAMPZ	= 0x3b
                                 .equ	SPMCSR	= 0x37
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUSR	= 0x34
                                 .equ	SMCR	= 0x33
                                 .equ	OCDR	= 0x31
                                 .equ	ACSR	= 0x30
                                 .equ	SPDR	= 0x2e
                                 .equ	SPSR	= 0x2d
                                 .equ	SPCR	= 0x2c
                                 .equ	GPIOR2	= 0x2b
                                 .equ	GPIOR1	= 0x2a
                                 .equ	OCR0B	= 0x28
                                 .equ	OCR0A	= 0x27
                                 .equ	TCNT0	= 0x26
                                 .equ	TCCR0B	= 0x25
                                 .equ	TCCR0A	= 0x24
                                 .equ	GTCCR	= 0x23
                                 .equ	EEARH	= 0x22
                                 .equ	EEARL	= 0x21
                                 .equ	EEDR	= 0x20
                                 .equ	EECR	= 0x1f
                                 .equ	GPIOR0	= 0x1e
                                 .equ	EIMSK	= 0x1d
                                 .equ	EIFR	= 0x1c
                                 .equ	PCIFR	= 0x1b
                                 .equ	TIFR5	= 0x1a
                                 .equ	TIFR4	= 0x19
                                 .equ	TIFR3	= 0x18
                                 .equ	TIFR2	= 0x17
                                 .equ	TIFR1	= 0x16
                                 .equ	TIFR0	= 0x15
                                 .equ	PORTG	= 0x14
                                 .equ	DDRG	= 0x13
                                 .equ	PING	= 0x12
                                 .equ	PORTF	= 0x11
                                 .equ	DDRF	= 0x10
                                 .equ	PINF	= 0x0f
                                 .equ	PORTE	= 0x0e
                                 .equ	DDRE	= 0x0d
                                 .equ	PINE	= 0x0c
                                 .equ	PORTD	= 0x0b
                                 .equ	DDRD	= 0x0a
                                 .equ	PIND	= 0x09
                                 .equ	PORTC	= 0x08
                                 .equ	DDRC	= 0x07
                                 .equ	PINC	= 0x06
                                 .equ	PORTB	= 0x05
                                 .equ	DDRB	= 0x04
                                 .equ	PINB	= 0x03
                                 .equ	PORTA	= 0x02
                                 .equ	DDRA	= 0x01
                                 .equ	PINA	= 0x00
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; ADCSRB - ADC Control and Status Register B
                                 .equ	ACME	= 6	; Analog Comparator Multiplexer Enable
                                 
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 ; DIDR1 - Digital Input Disable Register 1
                                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                                 
                                 
                                 ; ***** USART0 ***********************
                                 ; UDR0 - USART I/O Data Register
                                 .equ	UDR0_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR0_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR0_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR0_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR0_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR0_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR0_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR0_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR0A - USART Control and Status Register A
                                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                                 .equ	U2X0	= 1	; Double the USART transmission speed
                                 .equ	UPE0	= 2	; Parity Error
                                 .equ	DOR0	= 3	; Data overRun
                                 .equ	FE0	= 4	; Framing Error
                                 .equ	UDRE0	= 5	; USART Data Register Empty
                                 .equ	TXC0	= 6	; USART Transmitt Complete
                                 .equ	RXC0	= 7	; USART Receive Complete
                                 
                                 ; UCSR0B - USART Control and Status Register B
                                 .equ	TXB80	= 0	; Transmit Data Bit 8
                                 .equ	RXB80	= 1	; Receive Data Bit 8
                                 .equ	UCSZ02	= 2	; Character Size
                                 .equ	TXEN0	= 3	; Transmitter Enable
                                 .equ	RXEN0	= 4	; Receiver Enable
                                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR0C - USART Control and Status Register C
                                 .equ	UCPOL0	= 0	; Clock Polarity
                                 .equ	UCSZ00	= 1	; Character Size
                                 .equ	UCPHA0	= UCSZ00	; For compatibility
                                 .equ	UCSZ01	= 2	; Character Size
                                 .equ	UDORD0	= UCSZ01	; For compatibility
                                 .equ	USBS0	= 3	; Stop Bit Select
                                 .equ	UPM00	= 4	; Parity Mode Bit 0
                                 .equ	UPM01	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL00	= 6	; USART Mode Select
                                 .equ	UMSEL0	= UMSEL00	; For compatibility
                                 .equ	UMSEL01	= 7	; USART Mode Select
                                 .equ	UMSEL1	= UMSEL01	; For compatibility
                                 
                                 ; UBRR0H - USART Baud Rate Register High Byte
                                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR0L - USART Baud Rate Register Low Byte
                                 .equ	_UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	_UBRR1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** TWI **************************
                                 ; TWAMR - TWI (Slave) Address Mask Register
                                 .equ	TWAM0	= 1	; 
                                 .equ	TWAMR0	= TWAM0	; For compatibility
                                 .equ	TWAM1	= 2	; 
                                 .equ	TWAMR1	= TWAM1	; For compatibility
                                 .equ	TWAM2	= 3	; 
                                 .equ	TWAMR2	= TWAM2	; For compatibility
                                 .equ	TWAM3	= 4	; 
                                 .equ	TWAMR3	= TWAM3	; For compatibility
                                 .equ	TWAM4	= 5	; 
                                 .equ	TWAMR4	= TWAM4	; For compatibility
                                 .equ	TWAM5	= 6	; 
                                 .equ	TWAMR5	= TWAM5	; For compatibility
                                 .equ	TWAM6	= 7	; 
                                 .equ	TWAMR6	= TWAM6	; For compatibility
                                 
                                 ; TWBR - TWI Bit Rate register
                                 .equ	TWBR0	= 0	; 
                                 .equ	TWBR1	= 1	; 
                                 .equ	TWBR2	= 2	; 
                                 .equ	TWBR3	= 3	; 
                                 .equ	TWBR4	= 4	; 
                                 .equ	TWBR5	= 5	; 
                                 .equ	TWBR6	= 6	; 
                                 .equ	TWBR7	= 7	; 
                                 
                                 ; TWCR - TWI Control Register
                                 .equ	TWIE	= 0	; TWI Interrupt Enable
                                 .equ	TWEN	= 2	; TWI Enable Bit
                                 .equ	TWWC	= 3	; TWI Write Collition Flag
                                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                                 .equ	TWINT	= 7	; TWI Interrupt Flag
                                 
                                 ; TWSR - TWI Status Register
                                 .equ	TWPS0	= 0	; TWI Prescaler
                                 .equ	TWPS1	= 1	; TWI Prescaler
                                 .equ	TWS3	= 3	; TWI Status
                                 .equ	TWS4	= 4	; TWI Status
                                 .equ	TWS5	= 5	; TWI Status
                                 .equ	TWS6	= 6	; TWI Status
                                 .equ	TWS7	= 7	; TWI Status
                                 
                                 ; TWDR - TWI Data register
                                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                                 
                                 ; TWAR - TWI (Slave) Address register
                                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                                 
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** PORTA ************************
                                 ; PORTA - Port A Data Register
                                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                                 .equ	PA0	= 0	; For compatibility
                                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                                 .equ	PA1	= 1	; For compatibility
                                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                                 .equ	PA2	= 2	; For compatibility
                                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                                 .equ	PA3	= 3	; For compatibility
                                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                                 .equ	PA4	= 4	; For compatibility
                                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                                 .equ	PA5	= 5	; For compatibility
                                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                                 .equ	PA6	= 6	; For compatibility
                                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                                 .equ	PA7	= 7	; For compatibility
                                 
                                 ; DDRA - Port A Data Direction Register
                                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                                 
                                 ; PINA - Port A Input Pins
                                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                                 .equ	PC7	= 7	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** PORTE ************************
                                 ; PORTE - Data Register, Port E
                                 .equ	PORTE0	= 0	; 
                                 .equ	PE0	= 0	; For compatibility
                                 .equ	PORTE1	= 1	; 
                                 .equ	PE1	= 1	; For compatibility
                                 .equ	PORTE2	= 2	; 
                                 .equ	PE2	= 2	; For compatibility
                                 .equ	PORTE3	= 3	; 
                                 .equ	PE3	= 3	; For compatibility
                                 .equ	PORTE4	= 4	; 
                                 .equ	PE4	= 4	; For compatibility
                                 .equ	PORTE5	= 5	; 
                                 .equ	PE5	= 5	; For compatibility
                                 .equ	PORTE6	= 6	; 
                                 .equ	PE6	= 6	; For compatibility
                                 .equ	PORTE7	= 7	; 
                                 .equ	PE7	= 7	; For compatibility
                                 
                                 ; DDRE - Data Direction Register, Port E
                                 .equ	DDE0	= 0	; 
                                 .equ	DDE1	= 1	; 
                                 .equ	DDE2	= 2	; 
                                 .equ	DDE3	= 3	; 
                                 .equ	DDE4	= 4	; 
                                 .equ	DDE5	= 5	; 
                                 .equ	DDE6	= 6	; 
                                 .equ	DDE7	= 7	; 
                                 
                                 ; PINE - Input Pins, Port E
                                 .equ	PINE0	= 0	; 
                                 .equ	PINE1	= 1	; 
                                 .equ	PINE2	= 2	; 
                                 .equ	PINE3	= 3	; 
                                 .equ	PINE4	= 4	; 
                                 .equ	PINE5	= 5	; 
                                 .equ	PINE6	= 6	; 
                                 .equ	PINE7	= 7	; 
                                 
                                 
                                 ; ***** PORTF ************************
                                 ; PORTF - Data Register, Port F
                                 .equ	PORTF0	= 0	; 
                                 .equ	PF0	= 0	; For compatibility
                                 .equ	PORTF1	= 1	; 
                                 .equ	PF1	= 1	; For compatibility
                                 .equ	PORTF2	= 2	; 
                                 .equ	PF2	= 2	; For compatibility
                                 .equ	PORTF3	= 3	; 
                                 .equ	PF3	= 3	; For compatibility
                                 .equ	PORTF4	= 4	; 
                                 .equ	PF4	= 4	; For compatibility
                                 .equ	PORTF5	= 5	; 
                                 .equ	PF5	= 5	; For compatibility
                                 .equ	PORTF6	= 6	; 
                                 .equ	PF6	= 6	; For compatibility
                                 .equ	PORTF7	= 7	; 
                                 .equ	PF7	= 7	; For compatibility
                                 
                                 ; DDRF - Data Direction Register, Port F
                                 .equ	DDF0	= 0	; 
                                 .equ	DDF1	= 1	; 
                                 .equ	DDF2	= 2	; 
                                 .equ	DDF3	= 3	; 
                                 .equ	DDF4	= 4	; 
                                 .equ	DDF5	= 5	; 
                                 .equ	DDF6	= 6	; 
                                 .equ	DDF7	= 7	; 
                                 
                                 ; PINF - Input Pins, Port F
                                 .equ	PINF0	= 0	; 
                                 .equ	PINF1	= 1	; 
                                 .equ	PINF2	= 2	; 
                                 .equ	PINF3	= 3	; 
                                 .equ	PINF4	= 4	; 
                                 .equ	PINF5	= 5	; 
                                 .equ	PINF6	= 6	; 
                                 .equ	PINF7	= 7	; 
                                 
                                 
                                 ; ***** PORTG ************************
                                 ; PORTG - Data Register, Port G
                                 .equ	PORTG0	= 0	; 
                                 .equ	PG0	= 0	; For compatibility
                                 .equ	PORTG1	= 1	; 
                                 .equ	PG1	= 1	; For compatibility
                                 .equ	PORTG2	= 2	; 
                                 .equ	PG2	= 2	; For compatibility
                                 .equ	PORTG3	= 3	; 
                                 .equ	PG3	= 3	; For compatibility
                                 .equ	PORTG4	= 4	; 
                                 .equ	PG4	= 4	; For compatibility
                                 .equ	PORTG5	= 5	; 
                                 .equ	PG5	= 5	; For compatibility
                                 
                                 ; DDRG - Data Direction Register, Port G
                                 .equ	DDG0	= 0	; 
                                 .equ	DDG1	= 1	; 
                                 .equ	DDG2	= 2	; 
                                 .equ	DDG3	= 3	; 
                                 .equ	DDG4	= 4	; 
                                 .equ	DDG5	= 5	; 
                                 
                                 ; PING - Input Pins, Port G
                                 .equ	PING0	= 0	; 
                                 .equ	PING1	= 1	; 
                                 .equ	PING2	= 2	; 
                                 .equ	PING3	= 3	; 
                                 .equ	PING4	= 4	; 
                                 .equ	PING5	= 5	; 
                                 
                                 
                                 ; ***** PORTH ************************
                                 ; PORTH - PORT H Data Register
                                 .equ	PORTH0	= 0	; PORT H Data Register bit 0
                                 .equ	PH0	= 0	; For compatibility
                                 .equ	PORTH1	= 1	; PORT H Data Register bit 1
                                 .equ	PH1	= 1	; For compatibility
                                 .equ	PORTH2	= 2	; PORT H Data Register bit 2
                                 .equ	PH2	= 2	; For compatibility
                                 .equ	PORTH3	= 3	; PORT H Data Register bit 3
                                 .equ	PH3	= 3	; For compatibility
                                 .equ	PORTH4	= 4	; PORT H Data Register bit 4
                                 .equ	PH4	= 4	; For compatibility
                                 .equ	PORTH5	= 5	; PORT H Data Register bit 5
                                 .equ	PH5	= 5	; For compatibility
                                 .equ	PORTH6	= 6	; PORT H Data Register bit 6
                                 .equ	PH6	= 6	; For compatibility
                                 .equ	PORTH7	= 7	; PORT H Data Register bit 7
                                 .equ	PH7	= 7	; For compatibility
                                 
                                 ; DDRH - PORT H Data Direction Register
                                 .equ	DDH0	= 0	; PORT H Data Direction Register bit 0
                                 .equ	DDH1	= 1	; PORT H Data Direction Register bit 1
                                 .equ	DDH2	= 2	; PORT H Data Direction Register bit 2
                                 .equ	DDH3	= 3	; PORT H Data Direction Register bit 3
                                 .equ	DDH4	= 4	; PORT H Data Direction Register bit 4
                                 .equ	DDH5	= 5	; PORT H Data Direction Register bit 5
                                 .equ	DDH6	= 6	; PORT H Data Direction Register bit 6
                                 .equ	DDH7	= 7	; PORT H Data Direction Register bit 7
                                 
                                 ; PINH - PORT H Input Pins
                                 .equ	PINH0	= 0	; PORT H Input Pins bit 0
                                 .equ	PINH1	= 1	; PORT H Input Pins bit 1
                                 .equ	PINH2	= 2	; PORT H Input Pins bit 2
                                 .equ	PINH3	= 3	; PORT H Input Pins bit 3
                                 .equ	PINH4	= 4	; PORT H Input Pins bit 4
                                 .equ	PINH5	= 5	; PORT H Input Pins bit 5
                                 .equ	PINH6	= 6	; PORT H Input Pins bit 6
                                 .equ	PINH7	= 7	; PORT H Input Pins bit 7
                                 
                                 
                                 ; ***** PORTJ ************************
                                 ; PORTJ - PORT J Data Register
                                 .equ	PORTJ0	= 0	; PORT J Data Register bit 0
                                 .equ	PJ0	= 0	; For compatibility
                                 .equ	PORTJ1	= 1	; PORT J Data Register bit 1
                                 .equ	PJ1	= 1	; For compatibility
                                 .equ	PORTJ2	= 2	; PORT J Data Register bit 2
                                 .equ	PJ2	= 2	; For compatibility
                                 .equ	PORTJ3	= 3	; PORT J Data Register bit 3
                                 .equ	PJ3	= 3	; For compatibility
                                 .equ	PORTJ4	= 4	; PORT J Data Register bit 4
                                 .equ	PJ4	= 4	; For compatibility
                                 .equ	PORTJ5	= 5	; PORT J Data Register bit 5
                                 .equ	PJ5	= 5	; For compatibility
                                 .equ	PORTJ6	= 6	; PORT J Data Register bit 6
                                 .equ	PJ6	= 6	; For compatibility
                                 .equ	PORTJ7	= 7	; PORT J Data Register bit 7
                                 .equ	PJ7	= 7	; For compatibility
                                 
                                 ; DDRJ - PORT J Data Direction Register
                                 .equ	DDJ0	= 0	; PORT J Data Direction Register bit 0
                                 .equ	DDJ1	= 1	; PORT J Data Direction Register bit 1
                                 .equ	DDJ2	= 2	; PORT J Data Direction Register bit 2
                                 .equ	DDJ3	= 3	; PORT J Data Direction Register bit 3
                                 .equ	DDJ4	= 4	; PORT J Data Direction Register bit 4
                                 .equ	DDJ5	= 5	; PORT J Data Direction Register bit 5
                                 .equ	DDJ6	= 6	; PORT J Data Direction Register bit 6
                                 .equ	DDJ7	= 7	; PORT J Data Direction Register bit 7
                                 
                                 ; PINJ - PORT J Input Pins
                                 .equ	PINJ0	= 0	; PORT J Input Pins bit 0
                                 .equ	PINJ1	= 1	; PORT J Input Pins bit 1
                                 .equ	PINJ2	= 2	; PORT J Input Pins bit 2
                                 .equ	PINJ3	= 3	; PORT J Input Pins bit 3
                                 .equ	PINJ4	= 4	; PORT J Input Pins bit 4
                                 .equ	PINJ5	= 5	; PORT J Input Pins bit 5
                                 .equ	PINJ6	= 6	; PORT J Input Pins bit 6
                                 .equ	PINJ7	= 7	; PORT J Input Pins bit 7
                                 
                                 
                                 ; ***** PORTK ************************
                                 ; PORTK - PORT K Data Register
                                 .equ	PORTK0	= 0	; PORT K Data Register bit 0
                                 .equ	PK0	= 0	; For compatibility
                                 .equ	PORTK1	= 1	; PORT K Data Register bit 1
                                 .equ	PK1	= 1	; For compatibility
                                 .equ	PORTK2	= 2	; PORT K Data Register bit 2
                                 .equ	PK2	= 2	; For compatibility
                                 .equ	PORTK3	= 3	; PORT K Data Register bit 3
                                 .equ	PK3	= 3	; For compatibility
                                 .equ	PORTK4	= 4	; PORT K Data Register bit 4
                                 .equ	PK4	= 4	; For compatibility
                                 .equ	PORTK5	= 5	; PORT K Data Register bit 5
                                 .equ	PK5	= 5	; For compatibility
                                 .equ	PORTK6	= 6	; PORT K Data Register bit 6
                                 .equ	PK6	= 6	; For compatibility
                                 .equ	PORTK7	= 7	; PORT K Data Register bit 7
                                 .equ	PK7	= 7	; For compatibility
                                 
                                 ; DDRK - PORT K Data Direction Register
                                 .equ	DDK0	= 0	; PORT K Data Direction Register bit 0
                                 .equ	DDK1	= 1	; PORT K Data Direction Register bit 1
                                 .equ	DDK2	= 2	; PORT K Data Direction Register bit 2
                                 .equ	DDK3	= 3	; PORT K Data Direction Register bit 3
                                 .equ	DDK4	= 4	; PORT K Data Direction Register bit 4
                                 .equ	DDK5	= 5	; PORT K Data Direction Register bit 5
                                 .equ	DDK6	= 6	; PORT K Data Direction Register bit 6
                                 .equ	DDK7	= 7	; PORT K Data Direction Register bit 7
                                 
                                 ; PINK - PORT K Input Pins
                                 .equ	PINK0	= 0	; PORT K Input Pins bit 0
                                 .equ	PINK1	= 1	; PORT K Input Pins bit 1
                                 .equ	PINK2	= 2	; PORT K Input Pins bit 2
                                 .equ	PINK3	= 3	; PORT K Input Pins bit 3
                                 .equ	PINK4	= 4	; PORT K Input Pins bit 4
                                 .equ	PINK5	= 5	; PORT K Input Pins bit 5
                                 .equ	PINK6	= 6	; PORT K Input Pins bit 6
                                 .equ	PINK7	= 7	; PORT K Input Pins bit 7
                                 
                                 
                                 ; ***** PORTL ************************
                                 ; PORTL - PORT L Data Register
                                 .equ	PORTL0	= 0	; PORT L Data Register bit 0
                                 .equ	PL0	= 0	; For compatibility
                                 .equ	PORTL1	= 1	; PORT L Data Register bit 1
                                 .equ	PL1	= 1	; For compatibility
                                 .equ	PORTL2	= 2	; PORT L Data Register bit 2
                                 .equ	PL2	= 2	; For compatibility
                                 .equ	PORTL3	= 3	; PORT L Data Register bit 3
                                 .equ	PL3	= 3	; For compatibility
                                 .equ	PORTL4	= 4	; PORT L Data Register bit 4
                                 .equ	PL4	= 4	; For compatibility
                                 .equ	PORTL5	= 5	; PORT L Data Register bit 5
                                 .equ	PL5	= 5	; For compatibility
                                 .equ	PORTL6	= 6	; PORT L Data Register bit 6
                                 .equ	PL6	= 6	; For compatibility
                                 .equ	PORTL7	= 7	; PORT L Data Register bit 7
                                 .equ	PL7	= 7	; For compatibility
                                 
                                 ; DDRL - PORT L Data Direction Register
                                 .equ	DDL0	= 0	; PORT L Data Direction Register bit 0
                                 .equ	DDL1	= 1	; PORT L Data Direction Register bit 1
                                 .equ	DDL2	= 2	; PORT L Data Direction Register bit 2
                                 .equ	DDL3	= 3	; PORT L Data Direction Register bit 3
                                 .equ	DDL4	= 4	; PORT L Data Direction Register bit 4
                                 .equ	DDL5	= 5	; PORT L Data Direction Register bit 5
                                 .equ	DDL6	= 6	; PORT L Data Direction Register bit 6
                                 .equ	DDL7	= 7	; PORT L Data Direction Register bit 7
                                 
                                 ; PINL - PORT L Input Pins
                                 .equ	PINL0	= 0	; PORT L Input Pins bit 0
                                 .equ	PINL1	= 1	; PORT L Input Pins bit 1
                                 .equ	PINL2	= 2	; PORT L Input Pins bit 2
                                 .equ	PINL3	= 3	; PORT L Input Pins bit 3
                                 .equ	PINL4	= 4	; PORT L Input Pins bit 4
                                 .equ	PINL5	= 5	; PORT L Input Pins bit 5
                                 .equ	PINL6	= 6	; PORT L Input Pins bit 6
                                 .equ	PINL7	= 7	; PORT L Input Pins bit 7
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TIMSK0 - Timer/Counter0 Interrupt Mask Register
                                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0A	= 1	; Timer/Counter0 Output Compare Match A Interrupt Enable
                                 .equ	OCIE0B	= 2	; Timer/Counter0 Output Compare Match B Interrupt Enable
                                 
                                 ; TIFR0 - Timer/Counter0 Interrupt Flag register
                                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0A	= 1	; Timer/Counter0 Output Compare Flag 0A
                                 .equ	OCF0B	= 2	; Timer/Counter0 Output Compare Flag 0B
                                 
                                 ; TCCR0A - Timer/Counter  Control Register A
                                 .equ	WGM00	= 0	; Waveform Generation Mode
                                 .equ	WGM01	= 1	; Waveform Generation Mode
                                 .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
                                 .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
                                 .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
                                 .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
                                 
                                 ; TCCR0B - Timer/Counter Control Register B
                                 .equ	CS00	= 0	; Clock Select
                                 .equ	CS01	= 1	; Clock Select
                                 .equ	CS02	= 2	; Clock Select
                                 .equ	WGM02	= 3	; 
                                 .equ	FOC0B	= 6	; Force Output Compare B
                                 .equ	FOC0A	= 7	; Force Output Compare A
                                 
                                 ; TCNT0 - Timer/Counter0
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0A - Timer/Counter0 Output Compare Register
                                 .equ	OCR0A_0	= 0	; 
                                 .equ	OCR0A_1	= 1	; 
                                 .equ	OCR0A_2	= 2	; 
                                 .equ	OCR0A_3	= 3	; 
                                 .equ	OCR0A_4	= 4	; 
                                 .equ	OCR0A_5	= 5	; 
                                 .equ	OCR0A_6	= 6	; 
                                 .equ	OCR0A_7	= 7	; 
                                 
                                 ; OCR0B - Timer/Counter0 Output Compare Register
                                 .equ	OCR0B_0	= 0	; 
                                 .equ	OCR0B_1	= 1	; 
                                 .equ	OCR0B_2	= 2	; 
                                 .equ	OCR0B_3	= 3	; 
                                 .equ	OCR0B_4	= 4	; 
                                 .equ	OCR0B_5	= 5	; 
                                 .equ	OCR0B_6	= 6	; 
                                 .equ	OCR0B_7	= 7	; 
                                 
                                 ; GTCCR - General Timer/Counter Control Register
                                 .equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                                 .equ	PSR10	= PSRSYNC	; For compatibility
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TIMSK2 - Timer/Counter Interrupt Mask register
                                 .equ	TOIE2	= 0	; Timer/Counter2 Overflow Interrupt Enable
                                 .equ	TOIE2A	= TOIE2	; For compatibility
                                 .equ	OCIE2A	= 1	; Timer/Counter2 Output Compare Match A Interrupt Enable
                                 .equ	OCIE2B	= 2	; Timer/Counter2 Output Compare Match B Interrupt Enable
                                 
                                 ; TIFR2 - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 0	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2A	= 1	; Output Compare Flag 2A
                                 .equ	OCF2B	= 2	; Output Compare Flag 2B
                                 
                                 ; TCCR2A - Timer/Counter2 Control Register A
                                 .equ	WGM20	= 0	; Waveform Genration Mode
                                 .equ	WGM21	= 1	; Waveform Genration Mode
                                 .equ	COM2B0	= 4	; Compare Output Mode bit 0
                                 .equ	COM2B1	= 5	; Compare Output Mode bit 1
                                 .equ	COM2A0	= 6	; Compare Output Mode bit 1
                                 .equ	COM2A1	= 7	; Compare Output Mode bit 1
                                 
                                 ; TCCR2B - Timer/Counter2 Control Register B
                                 .equ	CS20	= 0	; Clock Select bit 0
                                 .equ	CS21	= 1	; Clock Select bit 1
                                 .equ	CS22	= 2	; Clock Select bit 2
                                 .equ	WGM22	= 3	; Waveform Generation Mode
                                 .equ	FOC2B	= 6	; Force Output Compare B
                                 .equ	FOC2A	= 7	; Force Output Compare A
                                 
                                 ; TCNT2 - Timer/Counter2
                                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                                 
                                 ; OCR2A - Timer/Counter2 Output Compare Register A
                                 .equ	OCR2A_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                                 .equ	OCR2A_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                                 .equ	OCR2A_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                                 .equ	OCR2A_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                                 .equ	OCR2A_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                                 .equ	OCR2A_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                                 .equ	OCR2A_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                                 .equ	OCR2A_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                                 
                                 ; OCR2B - Timer/Counter2 Output Compare Register B
                                 .equ	OCR2B_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                                 .equ	OCR2B_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                                 .equ	OCR2B_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                                 .equ	OCR2B_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                                 .equ	OCR2B_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                                 .equ	OCR2B_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                                 .equ	OCR2B_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                                 .equ	OCR2B_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                                 
                                 ; ASSR - Asynchronous Status Register
                                 .equ	TCR2BUB	= 0	; Timer/Counter Control Register2 Update Busy
                                 .equ	TCR2AUB	= 1	; Timer/Counter Control Register2 Update Busy
                                 .equ	OCR2BUB	= 2	; Output Compare Register 2 Update Busy
                                 .equ	OCR2AUB	= 3	; Output Compare Register2 Update Busy
                                 .equ	TCN2UB	= 4	; Timer/Counter2 Update Busy
                                 .equ	AS2	= 5	; Asynchronous Timer/Counter2
                                 .equ	EXCLK	= 6	; Enable External Clock Input
                                 
                                 ; GTCCR - General Timer Counter Control register
                                 .equ	PSRASY	= 1	; Prescaler Reset Timer/Counter2
                                 .equ	PSR2	= PSRASY	; For compatibility
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCSR - Watchdog Timer Control Register
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                                 
                                 
                                 ; ***** USART1 ***********************
                                 ; UDR1 - USART I/O Data Register
                                 .equ	UDR1_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR1_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR1_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR1_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR1_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR1_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR1_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR1_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR1A - USART Control and Status Register A
                                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                                 .equ	U2X1	= 1	; Double the USART transmission speed
                                 .equ	UPE1	= 2	; Parity Error
                                 .equ	DOR1	= 3	; Data overRun
                                 .equ	FE1	= 4	; Framing Error
                                 .equ	UDRE1	= 5	; USART Data Register Empty
                                 .equ	TXC1	= 6	; USART Transmitt Complete
                                 .equ	RXC1	= 7	; USART Receive Complete
                                 
                                 ; UCSR1B - USART Control and Status Register B
                                 .equ	TXB81	= 0	; Transmit Data Bit 8
                                 .equ	RXB81	= 1	; Receive Data Bit 8
                                 .equ	UCSZ12	= 2	; Character Size
                                 .equ	TXEN1	= 3	; Transmitter Enable
                                 .equ	RXEN1	= 4	; Receiver Enable
                                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR1C - USART Control and Status Register C
                                 .equ	UCPOL1	= 0	; Clock Polarity
                                 .equ	UCSZ10	= 1	; Character Size
                                 .equ	UCPHA1	= UCSZ10	; For compatibility
                                 .equ	UCSZ11	= 2	; Character Size
                                 .equ	UDORD1	= UCSZ11	; For compatibility
                                 .equ	USBS1	= 3	; Stop Bit Select
                                 .equ	UPM10	= 4	; Parity Mode Bit 0
                                 .equ	UPM11	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL10	= 6	; USART Mode Select
                                 .equ	UMSEL11	= 7	; USART Mode Select
                                 
                                 ; UBRR1H - USART Baud Rate Register High Byte
                                 .equ	UBRR_8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR_9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR_10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR_11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR1L - USART Baud Rate Register Low Byte
                                 .equ	UBRR_0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR_1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR_2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR_3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR_4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR_5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR_6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR_7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEARH - EEPROM Address Register Low Byte
                                 .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 8
                                 .equ	EEAR9	= 1	; EEPROM Read/Write Access Bit 9
                                 .equ	EEAR10	= 2	; EEPROM Read/Write Access Bit 10
                                 .equ	EEAR11	= 3	; EEPROM Read/Write Access Bit 11
                                 
                                 ; EEARL - EEPROM Address Register Low Byte
                                 .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                                 .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                                 .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                                 .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                                 .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                                 .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                                 .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                                 .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                                 
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEPE	= 1	; EEPROM Write Enable
                                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                                 .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                                 
                                 
                                 ; ***** TIMER_COUNTER_5 **************
                                 ; TIMSK5 - Timer/Counter5 Interrupt Mask Register
                                 .equ	TOIE5	= 0	; Timer/Counter5 Overflow Interrupt Enable
                                 .equ	OCIE5A	= 1	; Timer/Counter5 Output Compare A Match Interrupt Enable
                                 .equ	OCIE5B	= 2	; Timer/Counter5 Output Compare B Match Interrupt Enable
                                 .equ	OCIE5C	= 3	; Timer/Counter5 Output Compare C Match Interrupt Enable
                                 .equ	ICIE5	= 5	; Timer/Counter5 Input Capture Interrupt Enable
                                 
                                 ; TIFR5 - Timer/Counter5 Interrupt Flag register
                                 .equ	TOV5	= 0	; Timer/Counter5 Overflow Flag
                                 .equ	OCF5A	= 1	; Output Compare Flag 5A
                                 .equ	OCF5B	= 2	; Output Compare Flag 5B
                                 .equ	OCF5C	= 3	; Output Compare Flag 5C
                                 .equ	ICF5	= 5	; Input Capture Flag 5
                                 
                                 ; TCCR5A - Timer/Counter5 Control Register A
                                 .equ	WGM50	= 0	; Waveform Generation Mode
                                 .equ	WGM51	= 1	; Waveform Generation Mode
                                 .equ	COM5C0	= 2	; Compare Output Mode 5C, bit 0
                                 .equ	COM5C1	= 3	; Compare Output Mode 5C, bit 1
                                 .equ	COM5B0	= 4	; Compare Output Mode 5B, bit 0
                                 .equ	COM5B1	= 5	; Compare Output Mode 5B, bit 1
                                 .equ	COM5A0	= 6	; Compare Output Mode 5A, bit 0
                                 .equ	COM5A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR5B - Timer/Counter5 Control Register B
                                 .equ	CS50	= 0	; Prescaler source of Timer/Counter 5
                                 .equ	CS51	= 1	; Prescaler source of Timer/Counter 5
                                 .equ	CS52	= 2	; Prescaler source of Timer/Counter 5
                                 .equ	WGM52	= 3	; Waveform Generation Mode
                                 .equ	WGM53	= 4	; Waveform Generation Mode
                                 .equ	ICES5	= 6	; Input Capture 5 Edge Select
                                 .equ	ICNC5	= 7	; Input Capture 5 Noise Canceler
                                 
                                 ; TCCR5C - Timer/Counter 5 Control Register C
                                 .equ	FOC5C	= 5	; Force Output Compare 5C
                                 .equ	FOC5B	= 6	; Force Output Compare 5B
                                 .equ	FOC5A	= 7	; Force Output Compare 5A
                                 
                                 ; ICR5H - Timer/Counter5 Input Capture Register High Byte
                                 .equ	ICR5H0	= 0	; Timer/Counter5 Input Capture Register High Byte bit 0
                                 .equ	ICR5H1	= 1	; Timer/Counter5 Input Capture Register High Byte bit 1
                                 .equ	ICR5H2	= 2	; Timer/Counter5 Input Capture Register High Byte bit 2
                                 .equ	ICR5H3	= 3	; Timer/Counter5 Input Capture Register High Byte bit 3
                                 .equ	ICR5H4	= 4	; Timer/Counter5 Input Capture Register High Byte bit 4
                                 .equ	ICR5H5	= 5	; Timer/Counter5 Input Capture Register High Byte bit 5
                                 .equ	ICR5H6	= 6	; Timer/Counter5 Input Capture Register High Byte bit 6
                                 .equ	ICR5H7	= 7	; Timer/Counter5 Input Capture Register High Byte bit 7
                                 
                                 ; ICR5L - Timer/Counter5 Input Capture Register Low Byte
                                 .equ	ICR5L0	= 0	; Timer/Counter5 Input Capture Register Low Byte bit 0
                                 .equ	ICR5L1	= 1	; Timer/Counter5 Input Capture Register Low Byte bit 1
                                 .equ	ICR5L2	= 2	; Timer/Counter5 Input Capture Register Low Byte bit 2
                                 .equ	ICR5L3	= 3	; Timer/Counter5 Input Capture Register Low Byte bit 3
                                 .equ	ICR5L4	= 4	; Timer/Counter5 Input Capture Register Low Byte bit 4
                                 .equ	ICR5L5	= 5	; Timer/Counter5 Input Capture Register Low Byte bit 5
                                 .equ	ICR5L6	= 6	; Timer/Counter5 Input Capture Register Low Byte bit 6
                                 .equ	ICR5L7	= 7	; Timer/Counter5 Input Capture Register Low Byte bit 7
                                 
                                 
                                 ; ***** TIMER_COUNTER_4 **************
                                 ; TIMSK4 - Timer/Counter4 Interrupt Mask Register
                                 .equ	TOIE4	= 0	; Timer/Counter4 Overflow Interrupt Enable
                                 .equ	OCIE4A	= 1	; Timer/Counter4 Output Compare A Match Interrupt Enable
                                 .equ	OCIE4B	= 2	; Timer/Counter4 Output Compare B Match Interrupt Enable
                                 .equ	OCIE4C	= 3	; Timer/Counter4 Output Compare C Match Interrupt Enable
                                 .equ	ICIE4	= 5	; Timer/Counter4 Input Capture Interrupt Enable
                                 
                                 ; TIFR4 - Timer/Counter4 Interrupt Flag register
                                 .equ	TOV4	= 0	; Timer/Counter4 Overflow Flag
                                 .equ	OCF4A	= 1	; Output Compare Flag 4A
                                 .equ	OCF4B	= 2	; Output Compare Flag 4B
                                 .equ	OCF4C	= 3	; Output Compare Flag 4C
                                 .equ	ICF4	= 5	; Input Capture Flag 4
                                 
                                 ; TCCR4A - Timer/Counter4 Control Register A
                                 .equ	WGM40	= 0	; Waveform Generation Mode
                                 .equ	WGM41	= 1	; Waveform Generation Mode
                                 .equ	COM4C0	= 2	; Compare Output Mode 4C, bit 0
                                 .equ	COM4C1	= 3	; Compare Output Mode 4C, bit 1
                                 .equ	COM4B0	= 4	; Compare Output Mode 4B, bit 0
                                 .equ	COM4B1	= 5	; Compare Output Mode 4B, bit 1
                                 .equ	COM4A0	= 6	; Compare Output Mode 4A, bit 0
                                 .equ	COM4A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR4B - Timer/Counter4 Control Register B
                                 .equ	CS40	= 0	; Prescaler source of Timer/Counter 4
                                 .equ	CS41	= 1	; Prescaler source of Timer/Counter 4
                                 .equ	CS42	= 2	; Prescaler source of Timer/Counter 4
                                 .equ	WGM42	= 3	; Waveform Generation Mode
                                 .equ	WGM43	= 4	; Waveform Generation Mode
                                 .equ	ICES4	= 6	; Input Capture 4 Edge Select
                                 .equ	ICNC4	= 7	; Input Capture 4 Noise Canceler
                                 
                                 ; TCCR4C - Timer/Counter 4 Control Register C
                                 .equ	FOC4C	= 5	; Force Output Compare 4C
                                 .equ	FOC4B	= 6	; Force Output Compare 4B
                                 .equ	FOC4A	= 7	; Force Output Compare 4A
                                 
                                 
                                 ; ***** TIMER_COUNTER_3 **************
                                 ; TIMSK3 - Timer/Counter3 Interrupt Mask Register
                                 .equ	TOIE3	= 0	; Timer/Counter3 Overflow Interrupt Enable
                                 .equ	OCIE3A	= 1	; Timer/Counter3 Output Compare A Match Interrupt Enable
                                 .equ	OCIE3B	= 2	; Timer/Counter3 Output Compare B Match Interrupt Enable
                                 .equ	OCIE3C	= 3	; Timer/Counter3 Output Compare C Match Interrupt Enable
                                 .equ	ICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                                 
                                 ; TIFR3 - Timer/Counter3 Interrupt Flag register
                                 .equ	TOV3	= 0	; Timer/Counter3 Overflow Flag
                                 .equ	OCF3A	= 1	; Output Compare Flag 3A
                                 .equ	OCF3B	= 2	; Output Compare Flag 3B
                                 .equ	OCF3C	= 3	; Output Compare Flag 3C
                                 .equ	ICF3	= 5	; Input Capture Flag 3
                                 
                                 ; TCCR3A - Timer/Counter3 Control Register A
                                 .equ	WGM30	= 0	; Waveform Generation Mode
                                 .equ	WGM31	= 1	; Waveform Generation Mode
                                 .equ	COM3C0	= 2	; Compare Output Mode 3C, bit 0
                                 .equ	COM3C1	= 3	; Compare Output Mode 3C, bit 1
                                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                                 .equ	COM3A0	= 6	; Compare Output Mode 3A, bit 0
                                 .equ	COM3A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR3B - Timer/Counter3 Control Register B
                                 .equ	CS30	= 0	; Prescaler source of Timer/Counter 3
                                 .equ	CS31	= 1	; Prescaler source of Timer/Counter 3
                                 .equ	CS32	= 2	; Prescaler source of Timer/Counter 3
                                 .equ	WGM32	= 3	; Waveform Generation Mode
                                 .equ	WGM33	= 4	; Waveform Generation Mode
                                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                                 .equ	ICNC3	= 7	; Input Capture 3 Noise Canceler
                                 
                                 ; TCCR3C - Timer/Counter 3 Control Register C
                                 .equ	FOC3C	= 5	; Force Output Compare 3C
                                 .equ	FOC3B	= 6	; Force Output Compare 3B
                                 .equ	FOC3A	= 7	; Force Output Compare 3A
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK1 - Timer/Counter1 Interrupt Mask Register
                                 .equ	TOIE1	= 0	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1A	= 1	; Timer/Counter1 Output Compare A Match Interrupt Enable
                                 .equ	OCIE1B	= 2	; Timer/Counter1 Output Compare B Match Interrupt Enable
                                 .equ	OCIE1C	= 3	; Timer/Counter1 Output Compare C Match Interrupt Enable
                                 .equ	ICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; TIFR1 - Timer/Counter1 Interrupt Flag register
                                 .equ	TOV1	= 0	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1A	= 1	; Output Compare Flag 1A
                                 .equ	OCF1B	= 2	; Output Compare Flag 1B
                                 .equ	OCF1C	= 3	; Output Compare Flag 1C
                                 .equ	ICF1	= 5	; Input Capture Flag 1
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Waveform Generation Mode
                                 .equ	WGM11	= 1	; Waveform Generation Mode
                                 .equ	COM1C0	= 2	; Compare Output Mode 1C, bit 0
                                 .equ	COM1C1	= 3	; Compare Output Mode 1C, bit 1
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Compare Output Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                                 .equ	WGM12	= 3	; Waveform Generation Mode
                                 .equ	WGM13	= 4	; Waveform Generation Mode
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 ; TCCR1C - Timer/Counter 1 Control Register C
                                 .equ	FOC1C	= 5	; Force Output Compare 1C
                                 .equ	FOC1B	= 6	; Force Output Compare 1B
                                 .equ	FOC1A	= 7	; Force Output Compare 1A
                                 
                                 
                                 ; ***** JTAG *************************
                                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                                 .equ	IDRD	= OCDR7	; For compatibility
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; MCUSR - MCU Status Register
                                 .equ	JTRF	= 4	; JTAG Reset Flag
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register A
                                 .equ	ISC00	= 0	; External Interrupt Sense Control Bit
                                 .equ	ISC01	= 1	; External Interrupt Sense Control Bit
                                 .equ	ISC10	= 2	; External Interrupt Sense Control Bit
                                 .equ	ISC11	= 3	; External Interrupt Sense Control Bit
                                 .equ	ISC20	= 4	; External Interrupt Sense Control Bit
                                 .equ	ISC21	= 5	; External Interrupt Sense Control Bit
                                 .equ	ISC30	= 6	; External Interrupt Sense Control Bit
                                 .equ	ISC31	= 7	; External Interrupt Sense Control Bit
                                 
                                 ; EICRB - External Interrupt Control Register B
                                 .equ	ISC40	= 0	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC41	= 1	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC50	= 2	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC51	= 3	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC60	= 4	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC61	= 5	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC70	= 6	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC71	= 7	; External Interrupt 7-4 Sense Control Bit
                                 
                                 ; EIMSK - External Interrupt Mask Register
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                                 .equ	INT2	= 2	; External Interrupt Request 2 Enable
                                 .equ	INT3	= 3	; External Interrupt Request 3 Enable
                                 .equ	INT4	= 4	; External Interrupt Request 4 Enable
                                 .equ	INT5	= 5	; External Interrupt Request 5 Enable
                                 .equ	INT6	= 6	; External Interrupt Request 6 Enable
                                 .equ	INT7	= 7	; External Interrupt Request 7 Enable
                                 
                                 ; EIFR - External Interrupt Flag Register
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 .equ	INTF1	= 1	; External Interrupt Flag 1
                                 .equ	INTF2	= 2	; External Interrupt Flag 2
                                 .equ	INTF3	= 3	; External Interrupt Flag 3
                                 .equ	INTF4	= 4	; External Interrupt Flag 4
                                 .equ	INTF5	= 5	; External Interrupt Flag 5
                                 .equ	INTF6	= 6	; External Interrupt Flag 6
                                 .equ	INTF7	= 7	; External Interrupt Flag 7
                                 
                                 ; PCICR - Pin Change Interrupt Control Register
                                 .equ	PCIE0	= 0	; Pin Change Interrupt Enable 0
                                 .equ	PCIE1	= 1	; Pin Change Interrupt Enable 1
                                 .equ	PCIE2	= 2	; Pin Change Interrupt Enable 2
                                 
                                 ; PCIFR - Pin Change Interrupt Flag Register
                                 .equ	PCIF0	= 0	; Pin Change Interrupt Flag 0
                                 .equ	PCIF1	= 1	; Pin Change Interrupt Flag 1
                                 .equ	PCIF2	= 2	; Pin Change Interrupt Flag 2
                                 
                                 ; PCMSK2 - Pin Change Mask Register 2
                                 .equ	PCINT16	= 0	; Pin Change Enable Mask 16
                                 .equ	PCINT17	= 1	; Pin Change Enable Mask 17
                                 .equ	PCINT18	= 2	; Pin Change Enable Mask 18
                                 .equ	PCINT19	= 3	; Pin Change Enable Mask 19
                                 .equ	PCINT20	= 4	; Pin Change Enable Mask 20
                                 .equ	PCINT21	= 5	; Pin Change Enable Mask 21
                                 .equ	PCINT22	= 6	; Pin Change Enable Mask 22
                                 .equ	PCINT23	= 7	; Pin Change Enable Mask 23
                                 
                                 ; PCMSK1 - Pin Change Mask Register 1
                                 .equ	PCINT8	= 0	; Pin Change Enable Mask 8
                                 .equ	PCINT9	= 1	; Pin Change Enable Mask 9
                                 .equ	PCINT10	= 2	; Pin Change Enable Mask 10
                                 .equ	PCINT11	= 3	; Pin Change Enable Mask 11
                                 .equ	PCINT12	= 4	; Pin Change Enable Mask 12
                                 .equ	PCINT13	= 5	; Pin Change Enable Mask 13
                                 .equ	PCINT14	= 6	; Pin Change Enable Mask 14
                                 .equ	PCINT15	= 7	; Pin Change Enable Mask 15
                                 
                                 ; PCMSK0 - Pin Change Mask Register 0
                                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                                 .equ	PCINT4	= 4	; Pin Change Enable Mask 4
                                 .equ	PCINT5	= 5	; Pin Change Enable Mask 5
                                 .equ	PCINT6	= 6	; Pin Change Enable Mask 6
                                 .equ	PCINT7	= 7	; Pin Change Enable Mask 7
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                                 .equ	IVSEL	= 1	; Interrupt Vector Select
                                 .equ	PUD	= 4	; Pull-up disable
                                 ;.equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; MCUSR - MCU Status Register
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                                 
                                 ; XMCRA - External Memory Control Register A
                                 .equ	SRW00	= 0	; Wait state select bit lower page
                                 .equ	SRW01	= 1	; Wait state select bit lower page
                                 .equ	SRW10	= 2	; Wait state select bit upper page
                                 .equ	SRW11	= 3	; Wait state select bit upper page
                                 .equ	SRL0	= 4	; Wait state page limit
                                 .equ	SRL1	= 5	; Wait state page limit
                                 .equ	SRL2	= 6	; Wait state page limit
                                 .equ	SRE	= 7	; External SRAM Enable
                                 
                                 ; XMCRB - External Memory Control Register B
                                 .equ	XMM0	= 0	; External Memory High Mask
                                 .equ	XMM1	= 1	; External Memory High Mask
                                 .equ	XMM2	= 2	; External Memory High Mask
                                 .equ	XMBK	= 7	; External Memory Bus Keeper Enable
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                                 
                                 ; CLKPR - 
                                 .equ	CLKPS0	= 0	; 
                                 .equ	CLKPS1	= 1	; 
                                 .equ	CLKPS2	= 2	; 
                                 .equ	CLKPS3	= 3	; 
                                 .equ	CLKPCE	= 7	; 
                                 
                                 ; SMCR - Sleep Mode Control Register
                                 .equ	SE	= 0	; Sleep Enable
                                 .equ	SM0	= 1	; Sleep Mode Select bit 0
                                 .equ	SM1	= 2	; Sleep Mode Select bit 1
                                 .equ	SM2	= 3	; Sleep Mode Select bit 2
                                 
                                 ; RAMPZ - RAM Page Z Select Register
                                 .equ	RAMPZ0	= 0	; RAM Page Z Select Register Bit 0
                                 .equ	RAMPZ1	= 1	; RAM Page Z Select Register Bit 1
                                 
                                 ; EIND - Extended Indirect Register
                                 .equ	EIND0	= 0	; Bit 0
                                 
                                 ; GPIOR2 - General Purpose IO Register 2
                                 .equ	GPIOR20	= 0	; General Purpose IO Register 2 bit 0
                                 .equ	GPIOR21	= 1	; General Purpose IO Register 2 bit 1
                                 .equ	GPIOR22	= 2	; General Purpose IO Register 2 bit 2
                                 .equ	GPIOR23	= 3	; General Purpose IO Register 2 bit 3
                                 .equ	GPIOR24	= 4	; General Purpose IO Register 2 bit 4
                                 .equ	GPIOR25	= 5	; General Purpose IO Register 2 bit 5
                                 .equ	GPIOR26	= 6	; General Purpose IO Register 2 bit 6
                                 .equ	GPIOR27	= 7	; General Purpose IO Register 2 bit 7
                                 
                                 ; GPIOR1 - General Purpose IO Register 1
                                 .equ	GPIOR10	= 0	; General Purpose IO Register 1 bit 0
                                 .equ	GPIOR11	= 1	; General Purpose IO Register 1 bit 1
                                 .equ	GPIOR12	= 2	; General Purpose IO Register 1 bit 2
                                 .equ	GPIOR13	= 3	; General Purpose IO Register 1 bit 3
                                 .equ	GPIOR14	= 4	; General Purpose IO Register 1 bit 4
                                 .equ	GPIOR15	= 5	; General Purpose IO Register 1 bit 5
                                 .equ	GPIOR16	= 6	; General Purpose IO Register 1 bit 6
                                 .equ	GPIOR17	= 7	; General Purpose IO Register 1 bit 7
                                 
                                 ; GPIOR0 - General Purpose IO Register 0
                                 .equ	GPIOR00	= 0	; General Purpose IO Register 0 bit 0
                                 .equ	GPIOR01	= 1	; General Purpose IO Register 0 bit 1
                                 .equ	GPIOR02	= 2	; General Purpose IO Register 0 bit 2
                                 .equ	GPIOR03	= 3	; General Purpose IO Register 0 bit 3
                                 .equ	GPIOR04	= 4	; General Purpose IO Register 0 bit 4
                                 .equ	GPIOR05	= 5	; General Purpose IO Register 0 bit 5
                                 .equ	GPIOR06	= 6	; General Purpose IO Register 0 bit 6
                                 .equ	GPIOR07	= 7	; General Purpose IO Register 0 bit 7
                                 
                                 ; PRR1 - Power Reduction Register1
                                 .equ	PRUSART1	= 0	; Power Reduction USART1
                                 .equ	PRUSART2	= 1	; Power Reduction USART2
                                 .equ	PRUSART3	= 2	; Power Reduction USART3
                                 .equ	PRTIM3	= 3	; Power Reduction Timer/Counter3
                                 .equ	PRTIM4	= 4	; Power Reduction Timer/Counter4
                                 .equ	PRTIM5	= 5	; Power Reduction Timer/Counter5
                                 
                                 ; PRR0 - Power Reduction Register0
                                 .equ	PRADC	= 0	; Power Reduction ADC
                                 .equ	PRUSART0	= 1	; Power Reduction USART
                                 .equ	PRSPI	= 2	; Power Reduction Serial Peripheral Interface
                                 .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                                 .equ	PRTIM0	= 5	; Power Reduction Timer/Counter0
                                 .equ	PRTIM2	= 6	; Power Reduction Timer/Counter2
                                 .equ	PRTWI	= 7	; Power Reduction TWI
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register A
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADATE	= 5	; ADC  Auto Trigger Enable
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCSRB - The ADC Control and Status register B
                                 .equ	ADTS0	= 0	; ADC Auto Trigger Source bit 0
                                 .equ	ADTS1	= 1	; ADC Auto Trigger Source bit 1
                                 .equ	ADTS2	= 2	; ADC Auto Trigger Source bit 2
                                 .equ	MUX5	= 3	; Analog Channel and Gain Selection Bits
                                 ;.equ	ACME	= 6	; 
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 ; DIDR0 - Digital Input Disable Register
                                 .equ	ADC0D	= 0	; 
                                 .equ	ADC1D	= 1	; 
                                 .equ	ADC2D	= 2	; 
                                 .equ	ADC3D	= 3	; 
                                 .equ	ADC4D	= 4	; 
                                 .equ	ADC5D	= 5	; 
                                 .equ	ADC6D	= 6	; 
                                 .equ	ADC7D	= 7	; 
                                 
                                 ; DIDR2 - Digital Input Disable Register
                                 .equ	ADC8D	= 0	; 
                                 .equ	ADC9D	= 1	; 
                                 .equ	ADC10D	= 2	; 
                                 .equ	ADC11D	= 3	; 
                                 .equ	ADC12D	= 4	; 
                                 .equ	ADC13D	= 5	; 
                                 .equ	ADC14D	= 6	; 
                                 .equ	ADC15D	= 7	; 
                                 
                                 
                                 ; ***** BOOT_LOAD ********************
                                 ; SPMCSR - Store Program Memory Control Register
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read While Write section read enable
                                 .equ	SIGRD	= 5	; Signature Row Read
                                 .equ	RWWSB	= 6	; Read While Write Section Busy
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 
                                 ; ***** USART2 ***********************
                                 ; UDR2 - USART I/O Data Register
                                 .equ	UDR2_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR2_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR2_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR2_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR2_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR2_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR2_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR2_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR2A - USART Control and Status Register A
                                 .equ	MPCM2	= 0	; Multi-processor Communication Mode
                                 .equ	U2X2	= 1	; Double the USART transmission speed
                                 .equ	UPE2	= 2	; Parity Error
                                 .equ	DOR2	= 3	; Data overRun
                                 .equ	FE2	= 4	; Framing Error
                                 .equ	UDRE2	= 5	; USART Data Register Empty
                                 .equ	TXC2	= 6	; USART Transmitt Complete
                                 .equ	RXC2	= 7	; USART Receive Complete
                                 
                                 ; UCSR2B - USART Control and Status Register B
                                 .equ	TXB82	= 0	; Transmit Data Bit 8
                                 .equ	RXB82	= 1	; Receive Data Bit 8
                                 .equ	UCSZ22	= 2	; Character Size
                                 .equ	TXEN2	= 3	; Transmitter Enable
                                 .equ	RXEN2	= 4	; Receiver Enable
                                 .equ	UDRIE2	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE2	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE2	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR2C - USART Control and Status Register C
                                 .equ	UCPOL2	= 0	; Clock Polarity
                                 .equ	UCSZ20	= 1	; Character Size
                                 .equ	UCSZ21	= 2	; Character Size
                                 .equ	USBS2	= 3	; Stop Bit Select
                                 .equ	UPM20	= 4	; Parity Mode Bit 0
                                 .equ	UPM21	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL20	= 6	; USART Mode Select
                                 .equ	UMSEL21	= 7	; USART Mode Select
                                 
                                 ; UBRR2H - USART Baud Rate Register High Byte
                                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR2L - USART Baud Rate Register Low Byte
                                 .equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** USART3 ***********************
                                 ; UDR3 - USART I/O Data Register
                                 .equ	UDR3_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR3_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR3_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR3_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR3_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR3_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR3_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR3_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR3A - USART Control and Status Register A
                                 .equ	MPCM3	= 0	; Multi-processor Communication Mode
                                 .equ	U2X3	= 1	; Double the USART transmission speed
                                 .equ	UPE3	= 2	; Parity Error
                                 .equ	DOR3	= 3	; Data overRun
                                 .equ	FE3	= 4	; Framing Error
                                 .equ	UDRE3	= 5	; USART Data Register Empty
                                 .equ	TXC3	= 6	; USART Transmitt Complete
                                 .equ	RXC3	= 7	; USART Receive Complete
                                 
                                 ; UCSR3B - USART Control and Status Register B
                                 .equ	TXB83	= 0	; Transmit Data Bit 8
                                 .equ	RXB83	= 1	; Receive Data Bit 8
                                 .equ	UCSZ32	= 2	; Character Size
                                 .equ	TXEN3	= 3	; Transmitter Enable
                                 .equ	RXEN3	= 4	; Receiver Enable
                                 .equ	UDRIE3	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE3	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE3	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR3C - USART Control and Status Register C
                                 .equ	UCPOL3	= 0	; Clock Polarity
                                 .equ	UCSZ30	= 1	; Character Size
                                 .equ	UCSZ31	= 2	; Character Size
                                 .equ	USBS3	= 3	; Stop Bit Select
                                 .equ	UPM30	= 4	; Parity Mode Bit 0
                                 .equ	UPM31	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL30	= 6	; USART Mode Select
                                 .equ	UMSEL31	= 7	; USART Mode Select
                                 
                                 ; UBRR3H - USART Baud Rate Register High Byte
                                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR3L - USART Baud Rate Register Low Byte
                                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 ;.equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	CKOUT	= 6	; Clock output
                                 .equ	CKDIV8	= 7	; Divide clock by 8
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select Reset Vector
                                 .equ	BOOTSZ0	= 1	; Select Boot Size
                                 .equ	BOOTSZ1	= 2	; Select Boot Size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	WDTON	= 4	; Watchdog timer always on
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	JTAGEN	= 6	; Enable JTAG
                                 .equ	OCDEN	= 7	; Enable OCD
                                 
                                 ; EXTENDED fuse bits
                                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0x1ffff	; Note: Word address
                                 .equ	IOEND	= 0x01ff
                                 .equ	SRAM_START	= 0x0200
                                 .equ	SRAM_SIZE	= 8192
                                 .equ	RAMEND	= 0x21ff
                                 .equ	XRAMEND	= 0xffff
                                 .equ	E2END	= 0x0fff
                                 .equ	EEPROMEND	= 0x0fff
                                 .equ	EEADRBITS	= 12
                                 #pragma AVRPART MEMORY PROG_FLASH 262144
                                 #pragma AVRPART MEMORY EEPROM 4096
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 8192
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x200
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0x1f000
                                 .equ	NRWW_STOP_ADDR	= 0x1ffff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0x1efff
                                 .equ	PAGESIZE	= 128
                                 .equ	FIRSTBOOTSTART	= 0x1fe00
                                 .equ	SECONDBOOTSTART	= 0x1fc00
                                 .equ	THIRDBOOTSTART	= 0x1f800
                                 .equ	FOURTHBOOTSTART	= 0x1f000
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                                 .equ	INT3addr	= 0x0008	; External Interrupt Request 3
                                 .equ	INT4addr	= 0x000a	; External Interrupt Request 4
                                 .equ	INT5addr	= 0x000c	; External Interrupt Request 5
                                 .equ	INT6addr	= 0x000e	; External Interrupt Request 6
                                 .equ	INT7addr	= 0x0010	; External Interrupt Request 7
                                 .equ	PCI0addr	= 0x0012	; Pin Change Interrupt Request 0
                                 .equ	PCI1addr	= 0x0014	; Pin Change Interrupt Request 1
                                 .equ	PCI2addr	= 0x0016	; Pin Change Interrupt Request 2
                                 .equ	WDTaddr	= 0x0018	; Watchdog Time-out Interrupt
                                 .equ	OC2Aaddr	= 0x001a	; Timer/Counter2 Compare Match A
                                 .equ	OC2Baddr	= 0x001c	; Timer/Counter2 Compare Match B
                                 .equ	OVF2addr	= 0x001e	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x0020	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0022	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x0024	; Timer/Counter1 Compare Match B
                                 .equ	OC1Caddr	= 0x0026	; Timer/Counter1 Compare Match C
                                 .equ	OVF1addr	= 0x0028	; Timer/Counter1 Overflow
                                 .equ	OC0Aaddr	= 0x002a	; Timer/Counter0 Compare Match A
                                 .equ	OC0Baddr	= 0x002c	; Timer/Counter0 Compare Match B
                                 .equ	OVF0addr	= 0x002e	; Timer/Counter0 Overflow
                                 .equ	SPIaddr	= 0x0030	; SPI Serial Transfer Complete
                                 .equ	URXC0addr	= 0x0032	; USART0, Rx Complete
                                 .equ	UDRE0addr	= 0x0034	; USART0 Data register Empty
                                 .equ	UTXC0addr	= 0x0036	; USART0, Tx Complete
                                 .equ	ACIaddr	= 0x0038	; Analog Comparator
                                 .equ	ADCCaddr	= 0x003a	; ADC Conversion Complete
                                 .equ	ERDYaddr	= 0x003c	; EEPROM Ready
                                 .equ	ICP3addr	= 0x003e	; Timer/Counter3 Capture Event
                                 .equ	OC3Aaddr	= 0x0040	; Timer/Counter3 Compare Match A
                                 .equ	OC3Baddr	= 0x0042	; Timer/Counter3 Compare Match B
                                 .equ	OC3Caddr	= 0x0044	; Timer/Counter3 Compare Match C
                                 .equ	OVF3addr	= 0x0046	; Timer/Counter3 Overflow
                                 .equ	URXC1addr	= 0x0048	; USART1, Rx Complete
                                 .equ	UDRE1addr	= 0x004a	; USART1 Data register Empty
                                 .equ	UTXC1addr	= 0x004c	; USART1, Tx Complete
                                 .equ	TWIaddr	= 0x004e	; 2-wire Serial Interface
                                 .equ	SPMRaddr	= 0x0050	; Store Program Memory Read
                                 .equ	ICP4addr	= 0x0052	; Timer/Counter4 Capture Event
                                 .equ	OC4Aaddr	= 0x0054	; Timer/Counter4 Compare Match A
                                 .equ	OC4Baddr	= 0x0056	; Timer/Counter4 Compare Match B
                                 .equ	OC4Caddr	= 0x0058	; Timer/Counter4 Compare Match C
                                 .equ	OVF4addr	= 0x005a	; Timer/Counter4 Overflow
                                 .equ	ICP5addr	= 0x005c	; Timer/Counter5 Capture Event
                                 .equ	OC5Aaddr	= 0x005e	; Timer/Counter5 Compare Match A
                                 .equ	OC5Baddr	= 0x0060	; Timer/Counter5 Compare Match B
                                 .equ	OC5Caddr	= 0x0062	; Timer/Counter5 Compare Match C
                                 .equ	OVF5addr	= 0x0064	; Timer/Counter5 Overflow
                                 .equ	URXC2addr	= 0x0066	; USART2, Rx Complete
                                 .equ	UDRE2addr	= 0x0068	; USART2 Data register Empty
                                 .equ	UTXC2addr	= 0x006a	; USART2, Tx Complete
                                 .equ	URXC3addr	= 0x006c	; USART3, Rx Complete
                                 .equ	UDRE3addr	= 0x006e	; USART3 Data register Empty
                                 .equ	UTXC3addr	= 0x0070	; USART3, Tx Complete
                                 
                                 .equ	INT_VECTORS_SIZE	= 114	; size in words
                                 
                                 #endif  /* _M2560DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ; pro2.asm
                                 ;
                                 ; Created: 30/05/2017 10:16:41 PM
                                 ; Author : asafp
                                 ;
                                 
                                 .include "m2560def.inc"
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega2560.xml **********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m2560def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega2560
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega2560
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M2560DEF_INC_
                                 #endif  /* _M2560DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 
                                 .def temp = r16
                                 .def temp1 = r17
                                 .def temp2 = r18
                                 
                                 //KEYPAD REGISTERS
                                 .def row = r19 ; current row number
                                 .def col = r20 ; current column number
                                 .def rmask = r21 ; mask for current row during scan
                                 .def cmask = r22 ; mask for current column during scan
                                 
                                 //KEYPAD CONSTANTS
                                 .equ PORTLDIR = 0xF0 ; PD7-4: output, PD3-0, input
                                 .equ INITCOLMASK = 0xEF ; scan from the rightmost column,
                                 .equ INITROWMASK = 0x01 ; scan from the top row
                                 .equ ROWMASK = 0x0F ; for obtaining input from Port D
                                 
                                 .equ secondline = 0b10101000
                                 
                                 .include "macros.asm"
                                 
                                 .macro do_lcd_command
                                 	ldi r16, @0
                                 	rcall lcd_command
                                 	rcall lcd_wait
                                 .endmacro
                                 .macro do_lcd_data
                                 	ldi r16, @0
                                 	rcall lcd_data
                                 	rcall lcd_wait
                                 .endmacro
                                 
                                 .macro do_lcd_data_reg
                                 	mov r16, @0
                                 	rcall lcd_data
                                 	rcall lcd_wait
                                 .endmacro
                                 
                                 .macro clear
                                 	ldi YL, low(@0) ; load the memory address to Y
                                 	ldi YH, high(@0)
                                 	clr temp
                                 	st Y+, temp ; clear the two bytes at @0 in SRAM
                                 	st Y, temp
                                 .endmacro
                                 
                                 .macro resetLCD
                                 	do_lcd_command 0b00111000 ; 2x5x7
                                 	rcall sleep_5ms
                                 	do_lcd_command 0b00111000 ; 2x5x7
                                 	rcall sleep_1ms
                                 	do_lcd_command 0b00111000 ; 2x5x7
                                 	do_lcd_command 0b00111000 ; 2x5x7
                                 	do_lcd_command 0b00001000 ; display off?
                                 	do_lcd_command 0b00000001 ; clear display
                                 	do_lcd_command 0b00000110 ; increment, no display shift
                                 	do_lcd_command 0b00001100 ; Cursor on, bar, no blink
                                 .endmacro
                                 ///////////////////////////////////////////////////////////
                                 
                                 // STACK MACROS //////////////////////
                                 .macro pushStack
                                 	push temp
                                 	push temp1
                                 	push temp2
                                 	in temp, SREG
                                 	push temp ; Prologue starts.
                                 	push YH ; Save all conflict registers in the prologue.
                                 	push YL
                                 	push r25
                                 	push r24 ; Prologue ends.
                                 .endmacro
                                 
                                 .macro pushTemp
                                 	push temp
                                 	push temp1
                                 	push temp2
                                 	in temp, SREG
                                 	push temp ; Prologue starts.
                                 .endmacro
                                 
                                 
                                 .macro popStack
                                 	pop r24 ; Epilogue starts;
                                 	pop r25 ; Restore all conflict registers from the stack.
                                 	pop YL
                                 	pop YH
                                 	pop temp
                                 	out SREG, temp
                                 	pop temp2
                                 	pop temp1
                                 	pop temp
                                 .endmacro
                                 
                                 
                                 .macro popTemp
                                 	pop temp
                                 	out SREG, temp
                                 	pop temp2
                                 	pop temp1
                                 	pop temp
                                 .endmacro
                                 
                                 ///////////////////////////////////////////////////////////////////////////////////
                                 
                                 ///////////		INVENTORY MACROS //////////////////////////////////
                                 .macro setInventory  
                                 	;pushTemp
                                 	;arranges items in 2 byte blocks, 1st byte = stock, 2nd byte = cost
                                 	ldi YL, low(inventory)
                                 	ldi YH, high(inventory)
                                 	ldi temp, 1 ;1
                                 	st Y+, temp
                                 	ldi temp, 1 
                                 	st Y+, temp
                                 	ldi temp, 2 ;2	;  set to 0 for debug, change back to 2 when done
                                 	st Y+, temp
                                 	ldi temp, 2 
                                 	st Y+, temp
                                 	ldi temp, 3 ;3
                                 	st Y+, temp
                                 	ldi temp, 1 
                                 	st Y+, temp
                                 	ldi temp, 4 ;4
                                 	st Y+, temp
                                 	ldi temp, 2 
                                 	st Y+, temp
                                 	ldi temp, 0 ;5
                                 	st Y+, temp
                                 	ldi temp, 1 
                                 	st Y+, temp
                                 	ldi temp, 6 ;6
                                 	st Y+, temp
                                 	ldi temp, 2 
                                 	st Y+, temp
                                 	ldi temp, 7 ;7
                                 	st Y+, temp
                                 	ldi temp, 1 
                                 	st Y+, temp
                                 	ldi temp, 8 ;8
                                 	st Y+, temp
                                 	ldi temp, 2 
                                 	st Y+, temp
                                 	ldi temp, 9 ;9
                                 	st Y+, temp
                                 	ldi temp, 1 
                                 	st Y+, temp
                                 	;ldi YL, low(inventory)
                                 	;ldi YH, high(inventory)
                                 	;popTemp
                                 .endmacro
                                 
                                 // Compares menu to given input
                                 .macro checkIfMenu
                                 	;pushTemp 
                                 	lds temp, menu
                                 	cpi temp, @0
                                 	;popTemp
                                 .endMacro
                                 
                                 // Set menu to given input
                                 .macro setMenu
                                 	;pushTemp
                                 	ldi temp, @0
                                 	sts menu, temp
                                 	;popTemp
                                 .endMacro
                                 
                                 
                                 
                                 
                                 .macro isStockEmpty
                                 	;pushTemp 
                                 	getInventory @0
                                 	lds temp2, currentStock
                                 	cpi temp2, 0
                                 	;popTemp
                                 .endMacro
                                 ////////////////////////////////////////
                                 
                                 /////	COIN SCREEN MACROS //////////
                                 .macro incrementCoins
                                 	;pushTemp
                                 	lds temp, coins
                                 	inc temp
                                 	sts coins, temp
                                 	clr temp
                                 	;popTemp
                                 .endMacro
                                 
                                 .macro decrementCoins
                                 	;pushTemp
                                 	lds temp, coins
                                 	dec temp
                                 	sts coins, temp
                                 	clr temp
                                 	;popTemp
                                 .endMacro
                                 
                                 // THIS MACRO UPDATES THE ADMIN SCREEN WHEN WE WANT TO INCREMENT AND DECREMENT
                                 .macro updateAdminScreen
                                 	pushTemp
                                 	resetLCD			;First we reset LCD screen
                                 
                                 	do_lcd_data 'A'
                                 	do_lcd_data 'd'
                                 	do_lcd_data 'm'
                                 	do_lcd_data 'i'
                                 	do_lcd_data 'n'
                                 	do_lcd_data ' '
                                 	do_lcd_data 'M'
                                 	do_lcd_data 'o'
                                 	do_lcd_data 'd'
                                 	do_lcd_data 'e'
                                 	do_lcd_data ' '
                                 
                                 	
                                 	
                                 	lds temp, numPressed			;load in current item and print number
                                 	subi temp, -'0'
                                 	do_lcd_data_reg temp
                                 
                                 	do_lcd_command secondLine		;This writes on the second line
                                 	lds temp, currentStock			;now write current stock
                                 	subi temp, -'0'
                                 	do_lcd_data_reg temp
                                 
                                 	do_lcd_data ' '
                                 	do_lcd_data ' '
                                 	do_lcd_data ' '
                                 	do_lcd_data ' '
                                 	do_lcd_data ' '
                                 	do_lcd_data ' '
                                 	do_lcd_data ' '
                                 	ldi temp, 36
                                 	do_lcd_data_reg temp
                                 
                                 	lds temp, currentCost			;now write cost
                                 	subi temp, -'0'
                                 	do_lcd_data_reg temp
                                 	popTemp
                                 .endMacro
                                 ////////////////////////////////////
                                 
                                 .macro getInventory
                                 	pushTemp
                                 	ldi YH, high(inventory)
                                 	ldi YL, low(inventory)
                                 
                                 ;we want to increment 2(n-1)-1 times as we have to increment Y each time
                                 ; accept n as an integer
                                 	clr temp2		;use temp2 as counter
                                 	mov temp, @0
                                 	dec temp
                                 ;branch case for input of 1, i.e. dont shift just store
                                 	cpi temp, 0
                                 	breq store
                                 
                                 	lsl temp
                                 	dec temp ;in order to get the address 
                                 
                                 increment:
                                 	ld temp1, Y+
                                 	;sts currentStock, temp1
                                 	ld temp1, Y
                                 	;sts currentCost, temp1
                                 
                                 	cp temp, temp2
                                 	breq store
                                 	inc temp2			;increment counter
                                 	rjmp increment
                                 store:
                                 	ld temp1, Y
                                 	sts currentStock, temp1
                                 	ld temp1, Y + 
                                 	sts currentCost, temp1
                                 
                                 	popTemp
                                 .endMacro
                                 
                                 
                                 // we want to take current stock value, add one to it and store it in Y
                                 // Y value is obtained by calling getInventory
                                 .macro increaseStock 
                                 	pushTemp
                                 	lds temp2, currentStock
                                 
                                 	cpi temp2, 10   ;check if stock is larger than 10
                                 	breq exit
                                 
                                 	inc temp2		;add one to current stock
                                 	sts currentStock, temp2
                                 	st Y, temp2	
                                 exit:
                                 	popTemp
                                 .endMacro
                                 
                                 .macro decreaseStock 
                                 	pushTemp
                                 	lds temp2, currentStock
                                 	cpi temp2, 0    ;check if equal to zero
                                 	breq exit
                                 	dec temp2		;decrease stock by one
                                 
                                 	sts currentStock, temp2
                                 	st Y, temp2	
                                 exit:
                                 	popTemp
                                 .endMacro
                                 
                                 .macro increaseCost
                                 	pushTemp	
                                 	lds temp2, currentCost	
                                 	cpi temp2, 3		;check if equal to 3
                                 	breq exit
                                 	inc temp2			;Increase cost by one
                                 
                                 	sts currentCost, temp2		;update inventory and currentCost
                                 	std Y + 1, temp2
                                 exit:
                                 	popTemp
                                 .endMacro
                                 
                                 .macro decreaseCost 
                                 	pushTemp
                                 	lds temp2, currentCost
                                 	cpi temp2, 1
                                 	breq exit
                                 	dec temp2
                                 	sts currentCost, temp2		;update inventory and currentCost
                                 	std Y + 1, temp2
                                 exit:
                                 	popTemp
                                 
                                 
                                 .dseg
000200                           	menu: .byte 1 ; menu screen 1-5
000201                           	coins: .byte 1 ;keeps track of number of coins entered so far
                                 // TIMERS //
                                 TimeCounter:
000202                           	.byte 2 ; Two-byte counter for counting seconds.
                                 TempCounter:; Counts quater seconds 
000204                           	.byte 2 ; Temporary counter. Used to determine
                                 timer1:		; for start screen
000206                           	.byte 1
                                 timer3:		; for Out of stock screen
000207                           	.byte 1
                                 timer6:     ; Used for entering admin mode
000208                           	.byte 1
                                 
                                 // KEYPAD
                                 numPressed:		; current number pressed
000209                           	.byte 1
                                 prevNum:		; previous number pressed
00020a                           	.byte 1
                                 
                                 currentStock:
00020b                           	.byte 1
                                 currentCost:
00020c                           	.byte 1
                                 pattern:
00020d                           	.byte 1 //pattern for leds atm flash only
                                 //INTERUPTS
                                 .cseg
                                 	.org 0
000000 940c 019c                 		jmp RESET
                                 	.org INT0addr
000002 940c 044a                 		jmp EXT_INT0
                                 	.org INT1addr
000004 940c 04f1                 		jmp EXT_INT1   ;push button interrupt
                                 	.org OVF0addr
00002e 940c 03e8                 		jmp Timer0OVF ; Jump to the interrupt handler for
                                 						; Timer0 overflow.
                                 
                                 
                                 .include "keypad.asm"
                                 
                                 
                                 colloop:
000030 3044                      	cpi col, 4
000031 f0a9                      	breq zeroReturnBridge; If all keys are scanned, repeat.
000032 9360 010b                 	sts PORTL, cmask ; Otherwise, scan a column.
000034 ef1f                      	ldi temp1, 0xFF ; Slow down the scan operation.
                                 delay: 
000035 951a                      	dec temp1
000036 f7f1                      	brne delay
000037 9110 0109                 	lds temp1, PINL ; Read PORTL
000039 701f                      	andi temp1, ROWMASK ; Get the keypad output value
00003a 301f                      	cpi temp1, 0xF ; Check if any row is low
00003b f081                      	breq nextcol
                                 	; If yes, find which row is low
00003c e051                      	ldi rmask, INITROWMASK ; Initialize for row check
00003d 2733                      	clr row ; 
                                 
                                 rowloop:
00003e 3034                      	cpi row, 4
00003f f061                      	breq nextcol ; the row scan is over.
000040 2f21                      	mov temp2, temp1
000041 2325                      	and temp2, rmask ; check un-masked bit
000042 f069                      	breq convert ; if bit is clear, the key is pressed
000043 9533                      	inc row ; else move to the next row
000044 0f55                      	lsl rmask
000045 940c 003e                 	jmp rowloop
                                 
                                 zeroReturnBridge: // NO KEYS ARE SCANNED PREVIOUS NUMBER = 0!
000047 e000                      	ldi temp, 0
000048 9300 020a                 	sts prevNum, temp
00004a 940c 019b                 	jmp returnKeypad
                                 
                                 nextcol: ; if row scan is over
00004c 0f66                      	lsl cmask
00004d 9543                      	inc col ; increase column value
00004e 940c 0030                 	jmp colloop ; go to the next column
                                 
                                 convert:
000050 9100 0200
000052 3001                      	checkIfMenu 1			;if menu is 1 call select screen on button touch
000053 f0c9                      	breq branchSelectScreenBridge 
                                 	
000054 3043                      	cpi col, 3 ; If the pressed key is in col.3
000055 f089                      	breq lettersBridge ; we have a letter
                                 	; If the key is not in col.3 and
000056 3033                      	cpi row, 3 ; If the key is in row3,
000057 f099                      	breq symbolsBridge ; we have a symbol or 0
000058 2f73                      	mov r23, row ; Otherwise we have a number in 1-9
000059 0f77                      	lsl r23
00005a 0f73                      	add r23, row
00005b 0f74                      	add r23, col ; r23 = row*3 + col
00005c 5f7f                      	subi r23, -1 ; r23 = row*3 + col + '1'
                                 	
00005d 9100 0200
00005f 3002                      	checkIfMenu 2			//check if on menu 2 if not jump to end
000060 f041                      	breq storeKeypadBridge1
000061 9100 0200
000063 3006                      	checkIfMenu 6			//check if in admin mode
000064 f051                      	breq updateAdminBridge	//if in admin mode, we need to store the current press and display it and its variables
000065 940c 019b                 	jmp returnKeypad		
                                 
                                 	// Relative Key Branches
                                 lettersBridge:
000067 940c 0095                 	jmp letters
                                 storeKeyPadBridge1:
000069 940c 00f1                 	jmp storeKeyPad
                                 symbolsBridge:
00006b 940c 00cd                 	jmp symbols
                                 branchSelectScreenBridge:
00006d 940c 00ed                 	jmp branchSelectScreen
                                 updateAdminBridge:
                                 
00006f 930f
000070 931f
000071 932f
000072 b70f
000073 930f
000074 e0d2
000075 e0ce
000076 2722
000077 2f07
000078 950a
000079 3000
00007a f041
00007b 0f00
00007c 950a
00007d 9119
00007e 8118
00007f 1702
000080 f011
000081 9523
000082 cffa
000083 8118
000084 9310 020b
000086 9119
000087 9310 020c
000089 910f
00008a bf0f
00008b 912f
00008c 911f
00008d 910f                         	getInventory r23
00008e 9370 0209                     sts numPressed, r23		// here we store the number pressed from the keypad to update into our display
000090 b978                      	out portc, r23
                                 			
000091 940c 0126                 	jmp updateAdmin         // possibly have two updates one for the items attributes another to increment that item.
                                 							// Here we need to load a new item (getInventory) 
                                 returnKeyPadBridge1:
000093 940c 019b                 	jmp returnKeyPad
                                 
                                 letters:
                                 A:
000095 e471                      	ldi r23, 'A'
000096 0f73                      	add r23, row ; Get the ASCII value for the key
                                 
000097 9100 0200
000099 3006                      	checkIfMenu 6				; check if in admin mode. If we are we now wait for A, B and C
00009a f7c1                      	brne returnKeypadBridge1	
                                 	
00009b 3471                      	cpi r23, 'A'				; First check if A is pressed
00009c f499                      	brne B
                                 
00009d 930f
00009e 931f
00009f 932f
0000a0 b70f
0000a1 930f
0000a2 9120 020c
0000a4 3023
0000a5 f021
0000a6 9523
0000a7 9320 020c
0000a9 8329
0000aa 910f
0000ab bf0f
0000ac 912f
0000ad 911f
0000ae 910f                      	increaseCost				;if it is we increase the cost of the current item (doesn't work)
0000af c041                      	rjmp storeKeypad
                                 B:						
0000b0 3472                      	cpi r23, 'B'				;Check if B is pressed
0000b1 f499                      	brne C
0000b2 930f
0000b3 931f
0000b4 932f
0000b5 b70f
0000b6 930f
0000b7 9120 020c
0000b9 3021
0000ba f021
0000bb 952a
0000bc 9320 020c
0000be 8329
0000bf 910f
0000c0 bf0f
0000c1 912f
0000c2 911f
0000c3 910f                      	decreaseCost				;If its pressed decrease cost of current item (doesn't work)
0000c4 c02c                      	rjmp storeKeypad			
                                 C:
0000c5 e000                      	ldi temp, 0					;Check if C is pressed
0000c6 9300 020b                 	sts currentStock, temp		; If pressed make stock 0
0000c8 c028                      	rjmp storeKeypad			
                                 
                                 // Bridges for rjmps
                                 storeKeyPadBridge:	
0000c9 940c 00f1                 	jmp storeKeyPad
                                 
                                 returnKeyPadBridge:
0000cb 940c 019b                 	jmp returnKeyPad
                                 
                                 symbols:
0000cd 3040                      	cpi col, 0 ; Check if we have a star
0000ce f069                      	breq star
0000cf 3041                      	cpi col, 1 ; or if we have zero
0000d0 f0c9                      	breq zero
0000d1 e273                      	ldi r23, '#' ; if not we have hash
                                 
0000d2 9100 0200
0000d4 3004                      	checkIfMenu 4			;if on insert coins screen move to select screen
0000d5 f0b9                      	breq branchSelectScreen
                                 
0000d6 9100 0200
0000d8 3006                      	checkIfMenu 6			;if in admin mode move to select screen :)
0000d9 f099                      	breq branchSelectScreen
0000da 940c 019b                 	jmp returnKeypad
                                 star:
0000dc e27a                      	ldi r23, '*'		; Set to star
0000dd 9100 0200
0000df 3002                      	checkIfMenu 2		; ADMIN MODE requires setScreen menu (2)
0000e0 f751                      	brne returnKeypadBridge
                                 
0000e1 9100 020a                 	lds temp, prevNum	;at this point prevNum is previous value of the keypad
0000e3 320a                      	cpi temp, '*'		;now check previous value of numpressed was '*' so we dont reset the timer
0000e4 f061                      	breq storeKeypad	;store next '*' into numPressed
                                 
0000e5 e104                      	ldi temp, 20		;store 20 into timer5 to measure 5 secs for admin mode
0000e6 9300 0208                 	sts timer6, temp	
0000e8 940c 00f1                 	jmp storeKeypad		
                                 zero:
0000ea e070                      	ldi r23, 0 ; Set to zero
0000eb 940c 019b                 	jmp returnKeypad
                                 
                                 branchSelectScreen:
0000ed d17f                      	rcall selectScreen	
0000ee c0ac                      	rjmp returnKeypad
                                 branchOOSScreen:
0000ef d1bc                      	rcall outOfStockScreen
                                 	;clr r23
0000f0 c0aa                      	rjmp returnKeypad
                                 
                                 // Store keypad when we need output value otherwise return
                                 storeKeypad:
0000f1 9100 0200
0000f3 3006                      	checkIfMenu 6			; if in menu 6 (Admin mode), dont store numpressed as we will set it with digit code. This just handles A,B and C
0000f4 f189                      	breq updateAdmin		; update admin menu that writes the new values for changed item attributes
                                 
0000f5 9370 0209                 	sts numPressed, r23   //here we store r23 into numpressed just cause...
0000f7 327a                      	cpi r23, '*'			; if * is pressed return and store it in previous
0000f8 f151                      	breq storePrev
                                 
0000f9 9100 0200
0000fb 3002                      	checkIfMenu 2			//check again if menu = 2 
0000fc f671                      	brne returnKeypadBridge		//if it doesn't jump to end, if it does do macro
0000fd 930f
0000fe 931f
0000ff 932f
000100 b70f
000101 930f
000102 e0d2
000103 e0ce
000104 2722
000105 2f07
000106 950a
000107 3000
000108 f041
000109 0f00
00010a 950a
00010b 9119
00010c 8118
00010d 1702
00010e f011
00010f 9523
000110 cffa
000111 8118
000112 9310 020b
000114 9119
000115 9310 020c
000117 910f
000118 bf0f
000119 912f
00011a 911f
00011b 910f
00011c 9120 020b
00011e 3020                      	isStockEmpty r23		//if true, branch to the out of stock screen
00011f f279                      	breq branchOOSScreen
                                 	
000120 d1dc                      	rcall coinScreen
000121 940c 019b                 	jmp returnKeypad
                                 
                                 storePrev:
000123 9370 020a                 	sts prevNum, r23
000125 c075                      	rjmp returnKeypad
                                 updateAdmin:
000126 930f
000127 931f
000128 932f
000129 b70f
00012a 930f
00012b e308
00012c d4df
00012d d4ee
00012e d507
00012f e308
000130 d4db
000131 d4ea
000132 d4fa
000133 e308
000134 d4d7
000135 d4e6
000136 e308
000137 d4d4
000138 d4e3
000139 e008
00013a d4d1
00013b d4e0
00013c e001
00013d d4ce
00013e d4dd
00013f e006
000140 d4cb
000141 d4da
000142 e00c
000143 d4c8
000144 d4d7
000145 e401
000146 d4cc
000147 d4d4
000148 e604
000149 d4c9
00014a d4d1
00014b e60d
00014c d4c6
00014d d4ce
00014e e609
00014f d4c3
000150 d4cb
000151 e60e
000152 d4c0
000153 d4c8
000154 e200
000155 d4bd
000156 d4c5
000157 e40d
000158 d4ba
000159 d4c2
00015a e60f
00015b d4b7
00015c d4bf
00015d e604
00015e d4b4
00015f d4bc
000160 e605
000161 d4b1
000162 d4b9
000163 e200
000164 d4ae
000165 d4b6
000166 9100 0209
000168 5d00
000169 2f00
00016a d4a8
00016b d4b0
00016c ea08
00016d d49e
00016e d4ad
00016f 9100 020b
000171 5d00
000172 2f00
000173 d49f
000174 d4a7
000175 e200
000176 d49c
000177 d4a4
000178 e200
000179 d499
00017a d4a1
00017b e200
00017c d496
00017d d49e
00017e e200
00017f d493
000180 d49b
000181 e200
000182 d490
000183 d498
000184 e200
000185 d48d
000186 d495
000187 e200
000188 d48a
000189 d492
00018a e204
00018b 2f00
00018c d486
00018d d48e
00018e 9100 020c
000190 5d00
000191 2f00
000192 d480
000193 d488
000194 910f
000195 bf0f
000196 912f
000197 911f
000198 910f                      	updateAdminScreen
000199 9100 020c                 	lds temp, currentCost
                                 	;out portc, temp	
                                 
                                 returnKeypad:
00019b 9508                      	ret
                                 	
                                 
                                 .include "inventory.asm"
                                 
                                 ;.def temp1 = r17	;n  = holds item num
                                 ;.def temp2 = r18	; counter = for incrementing
                                 
                                 .dseg
                                 inventory: 
00020e                           	.byte 18
                                 .cseg 
                                 //setInventory
                                 
                                 //temp1 = position wanted
                                 
                                 
                                 
                                 
                                 
                                 RESET:
                                 	// INTIATE STACK
00019c ef0f                      	ldi r16, low(RAMEND)
00019d bf0d                      	out SPL, r16
00019e e201                      	ldi r16, high(RAMEND)
00019f bf0e                      	out SPH, r16
                                 
                                 	// LCD RESET
0001a0 ef0f                      	ser r16
0001a1 bb00                      	out DDRF, r16
0001a2 b907                      	out DDRC, r16
0001a3 b901                      	out DDRA, r16
0001a4 bb03                      	out DDRG, r16
0001a5 2700                      	clr r16
0001a6 bb01                      	out PORTF, r16
0001a7 b902                      	out PORTA, r16
0001a8 b908                      	out PORTC, r16
0001a9 bb04                      	out PORTG, r16
0001aa 2777                      	clr r23
                                 	// TIMER RESET//
0001ab e0c4
0001ac e0d2
0001ad 2700
0001ae 9309
0001af 8308                      	clear TempCounter ; Initialize the temporary counter to 0
0001b0 e0c2
0001b1 e0d2
0001b2 2700
0001b3 9309
0001b4 8308                      	clear TimeCounter ; Initialize the second counter to 0
0001b5 e000                      	ldi temp, 0b00000000
0001b6 bd04                      	out TCCR0A, temp
0001b7 e002                      	ldi temp, 0b00000010
0001b8 bd05                      	out TCCR0B, temp ; Prescaling value=8
0001b9 e001                      	ldi temp, 1<<TOIE0 ; = 128 microseconds
0001ba 9300 006e                 	sts TIMSK0, temp ; T/C0 interrupt enable
                                 
                                 
                                 	// KEYPAD RESET
0001bc ef10                      	ldi temp1, PORTLDIR ; PA7:4/PA3:0, out/in
0001bd 9310 010a                 	sts DDRL, temp1
                                 
                                 	// PUSH BUTTON INITIALISATION 
0001bf e002                      	ldi temp, (2<<ISC00)	;set INT0 as falling edge triggered interupt
0001c0 9300 0069                 	sts EICRA, temp
0001c2 b30d                      	in temp, EIMSK			;enable INT0 & INT1
0001c3 6001                      	ori temp, (1<<INT0)
0001c4 6002                      	ori temp, (1<<INT1)
0001c5 bb0d                      	out EIMSK, temp
                                 
0001c6 9478                      	sei ; Enable global interrupt
                                 
                                 	// INVENTORY INITIALISATION
0001c7 e0ce
0001c8 e0d2
0001c9 e001
0001ca 9309
0001cb e001
0001cc 9309
0001cd e002
0001ce 9309
0001cf e002
0001d0 9309
0001d1 e003
0001d2 9309
0001d3 e001
0001d4 9309
0001d5 e004
0001d6 9309
0001d7 e002
0001d8 9309
0001d9 e000
0001da 9309
0001db e001
0001dc 9309
0001dd e006
0001de 9309
0001df e002
0001e0 9309
0001e1 e007
0001e2 9309
0001e3 e001
0001e4 9309
0001e5 e008
0001e6 9309
0001e7 e002
0001e8 9309
0001e9 e009
0001ea 9309
0001eb e001
0001ec 9309                      	setInventory
                                 
                                 	// CONSTANTS
0001ed e000                      	ldi temp, 0
0001ee 9300 0201                 	sts coins, temp
                                 
0001f0 d001                      	rcall startScreen
0001f1 c1f2                      	rjmp main			;go to main to start polling, reset finished
                                 
                                 startScreen: ;start screen is part of reset function
0001f2 e001
0001f3 9300 0200                 	setMenu 1
                                 	;out portc, temp
                                 
0001f5 e308
0001f6 d415
0001f7 d424
0001f8 d43d
0001f9 e308
0001fa d411
0001fb d420
0001fc d430
0001fd e308
0001fe d40d
0001ff d41c
000200 e308
000201 d40a
000202 d419
000203 e008
000204 d407
000205 d416
000206 e001
000207 d404
000208 d413
000209 e006
00020a d401
00020b d410
00020c e00c
00020d d3fe
00020e d40d                      	resetLCD
                                 
00020f e302
000210 d402
000211 d40a                      	do_lcd_data '2'
000212 e301
000213 d3ff
000214 d407                      	do_lcd_data '1'
000215 e302
000216 d3fc
000217 d404                      	do_lcd_data '2'
000218 e301
000219 d3f9
00021a d401                      	do_lcd_data '1'
00021b e200
00021c d3f6
00021d d3fe                      	do_lcd_data ' '
00021e e301
00021f d3f3
000220 d3fb                      	do_lcd_data '1'
000221 e307
000222 d3f0
000223 d3f8                      	do_lcd_data '7'
000224 e703
000225 d3ed
000226 d3f5                      	do_lcd_data 's'
000227 e301
000228 d3ea
000229 d3f2                      	do_lcd_data '1'
00022a e200
00022b d3e7
00022c d3ef                      	do_lcd_data ' '
00022d e200
00022e d3e4
00022f d3ec                      	do_lcd_data ' '
000230 e200
000231 d3e1
000232 d3e9                      	do_lcd_data ' '
000233 e401
000234 d3de
000235 d3e6                      	do_lcd_data 'A'
000236 e304
000237 d3db
000238 d3e3                      	do_lcd_data '4'
                                 
000239 ea08
00023a d3d1
00023b d3e0                      	do_lcd_command secondLine
                                 
00023c e506
00023d d3d5
00023e d3dd                      	do_lcd_data 'V'
00023f e605
000240 d3d2
000241 d3da                      	do_lcd_data 'e'
000242 e60e
000243 d3cf
000244 d3d7                      	do_lcd_data 'n'
000245 e604
000246 d3cc
000247 d3d4                      	do_lcd_data 'd'
000248 e609
000249 d3c9
00024a d3d1                      	do_lcd_data 'i'
00024b e60e
00024c d3c6
00024d d3ce                      	do_lcd_data 'n'
00024e e607
00024f d3c3
000250 d3cb                      	do_lcd_data 'g'
000251 e200
000252 d3c0
000253 d3c8                      	do_lcd_data ' '
000254 e40d
000255 d3bd
000256 d3c5                      	do_lcd_data 'M'
000257 e601
000258 d3ba
000259 d3c2                      	do_lcd_data 'a'
00025a e603
00025b d3b7
00025c d3bf                      	do_lcd_data 'c'
00025d e608
00025e d3b4
00025f d3bc                      	do_lcd_data 'h'
000260 e609
000261 d3b1
000262 d3b9                      	do_lcd_data 'i'
000263 e60e
000264 d3ae
000265 d3b6                      	do_lcd_data 'n'
000266 e605
000267 d3ab
000268 d3b3                      	do_lcd_data 'e'
                                 	
000269 e00c                      	ldi temp, 12	; for 3 seconds, intitilise to 13, because every 0.25s x 4 = 1 *3 = 12;
00026a 9300 0206                 	sts timer1, temp
00026c 9508                      	ret
                                 
                                 selectScreen:
00026d e002
00026e 9300 0200                 	setMenu 2
                                 	;out portc, temp
                                 
000270 e308
000271 d39a
000272 d3a9
000273 d3c2
000274 e308
000275 d396
000276 d3a5
000277 d3b5
000278 e308
000279 d392
00027a d3a1
00027b e308
00027c d38f
00027d d39e
00027e e008
00027f d38c
000280 d39b
000281 e001
000282 d389
000283 d398
000284 e006
000285 d386
000286 d395
000287 e00c
000288 d383
000289 d392                      	resetLCD
                                 
00028a e503
00028b d387
00028c d38f                      	do_lcd_data 'S'
00028d e605
00028e d384
00028f d38c                      	do_lcd_data 'e'
000290 e60c
000291 d381
000292 d389                      	do_lcd_data 'l'
000293 e605
000294 d37e
000295 d386                      	do_lcd_data 'e'
000296 e603
000297 d37b
000298 d383                      	do_lcd_data 'c'
000299 e704
00029a d378
00029b d380                      	do_lcd_data 't'
00029c e200
00029d d375
00029e d37d                      	do_lcd_data ' '
00029f e609
0002a0 d372
0002a1 d37a                      	do_lcd_data 'i'
0002a2 e704
0002a3 d36f
0002a4 d377                      	do_lcd_data 't'
0002a5 e605
0002a6 d36c
0002a7 d374                      	do_lcd_data 'e'
0002a8 e60d
0002a9 d369
0002aa d371                      	do_lcd_data 'm'
0002ab 9508                      	ret
                                 
                                 outOfStockScreen:
                                 	
0002ac e308
0002ad d35e
0002ae d36d
0002af d386
0002b0 e308
0002b1 d35a
0002b2 d369
0002b3 d379
0002b4 e308
0002b5 d356
0002b6 d365
0002b7 e308
0002b8 d353
0002b9 d362
0002ba e008
0002bb d350
0002bc d35f
0002bd e001
0002be d34d
0002bf d35c
0002c0 e006
0002c1 d34a
0002c2 d359
0002c3 e00c
0002c4 d347
0002c5 d356                      	resetLCD
                                 
0002c6 e40f
0002c7 d34b
0002c8 d353                      	do_lcd_data 'O'
0002c9 e705
0002ca d348
0002cb d350                      	do_lcd_data 'u'
0002cc e704
0002cd d345
0002ce d34d                      	do_lcd_data 't'
0002cf e200
0002d0 d342
0002d1 d34a                      	do_lcd_data ' '
0002d2 e60f
0002d3 d33f
0002d4 d347                      	do_lcd_data 'o'
0002d5 e606
0002d6 d33c
0002d7 d344                      	do_lcd_data 'f'
0002d8 e200
0002d9 d339
0002da d341                      	do_lcd_data ' '
0002db e703
0002dc d336
0002dd d33e                      	do_lcd_data 's'
0002de e704
0002df d333
0002e0 d33b                      	do_lcd_data 't'
0002e1 e60f
0002e2 d330
0002e3 d338                      	do_lcd_data 'o'
0002e4 e603
0002e5 d32d
0002e6 d335                      	do_lcd_data 'c'
0002e7 e60b
0002e8 d32a
0002e9 d332                      	do_lcd_data 'k'
                                 
0002ea ea08
0002eb d320
0002ec d32f                      	do_lcd_command secondLine
                                 
                                 	;out PORTC, temp1
0002ed 9110 0209                 	lds temp1, numPressed
0002ef 5d10                      	subi temp1, -'0'
0002f0 2f01
0002f1 d321
0002f2 d329                      	do_lcd_data_reg temp1		;temp1 holds what key was pressed, we convert it to ascii, print it out to lcd
                                 
                                 
                                 	;We will have a check to see when this equals 6 i.e. 1.5secs to toggle led's
0002f3 e003
0002f4 9300 0200                 	setMenu 3
0002f6 e00c                      	ldi temp, 12	;for 3 seconds, intitilise to 12, because every 0.25s x 4 = 1 *3 = 12;
0002f7 9300 0207                 	sts timer3, temp
0002f9 e000                      	ldi temp, 0b00000000
0002fa 9300 020d                 	sts pattern, temp
0002fc 9508                      	ret
                                 
                                 coinScreen:
0002fd e004
0002fe 9300 0200                 	setMenu 4
                                 
000300 e308
000301 d30a
000302 d319
000303 d332
000304 e308
000305 d306
000306 d315
000307 d325
000308 e308
000309 d302
00030a d311
00030b e308
00030c d2ff
00030d d30e
00030e e008
00030f d2fc
000310 d30b
000311 e001
000312 d2f9
000313 d308
000314 e006
000315 d2f6
000316 d305
000317 e00c
000318 d2f3
000319 d302                      	resetLCD
                                 
00031a e409
00031b d2f7
00031c d2ff                      	do_lcd_data 'I'
00031d e60e
00031e d2f4
00031f d2fc                      	do_lcd_data 'n'
000320 e703
000321 d2f1
000322 d2f9                      	do_lcd_data 's'
000323 e605
000324 d2ee
000325 d2f6                      	do_lcd_data 'e'
000326 e702
000327 d2eb
000328 d2f3                      	do_lcd_data 'r'
000329 e704
00032a d2e8
00032b d2f0                      	do_lcd_data 't'
00032c e200
00032d d2e5
00032e d2ed                      	do_lcd_data ' '
00032f e603
000330 d2e2
000331 d2ea                      	do_lcd_data 'c'
000332 e60f
000333 d2df
000334 d2e7                      	do_lcd_data 'o'
000335 e609
000336 d2dc
000337 d2e4                      	do_lcd_data 'i'
000338 e60e
000339 d2d9
00033a d2e1                      	do_lcd_data 'n'
00033b e703
00033c d2d6
00033d d2de                      	do_lcd_data 's'
                                 
00033e ea08
00033f d2cc
000340 d2db                      	do_lcd_command secondLine
                                 	
                                 	// PRINT TO LED NUMBER OF COINS BEEN ENTERED, LEAVE IN, NOT DEBUGGING!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
000341 9100 0201                 	lds temp, coins
000343 b908                      	out portc, temp
                                 	// SHOW NUMBER OF COINS REMAINING = CURRENTCOST - COINS ENTERED
000344 9110 020c                 	lds temp1, currentCost
000346 1b10                      	sub temp1, temp
000347 5d10                      	subi temp1, -'0'
000348 2f01
000349 d2c9
00034a d2d1                      	do_lcd_data_reg temp1
                                 	
00034b 9508                      	ret
                                 
                                 
                                 	///ADMIN MODE
                                 enterAdminMode:
00034c 930f
00034d 931f
00034e 932f
00034f b70f
000350 930f                      	pushTemp
000351 e308
000352 d2b9
000353 d2c8
000354 d2e1
000355 e308
000356 d2b5
000357 d2c4
000358 d2d4
000359 e308
00035a d2b1
00035b d2c0
00035c e308
00035d d2ae
00035e d2bd
00035f e008
000360 d2ab
000361 d2ba
000362 e001
000363 d2a8
000364 d2b7
000365 e006
000366 d2a5
000367 d2b4
000368 e00c
000369 d2a2
00036a d2b1                      	resetLCD
                                 
00036b e006
00036c 9300 0200                 	setMenu 6
                                 
00036e e401
00036f d2a3
000370 d2ab                      	do_lcd_data 'A'
000371 e604
000372 d2a0
000373 d2a8                      	do_lcd_data 'd'
000374 e60d
000375 d29d
000376 d2a5                      	do_lcd_data 'm'
000377 e609
000378 d29a
000379 d2a2                      	do_lcd_data 'i'
00037a e60e
00037b d297
00037c d29f                      	do_lcd_data 'n'
00037d e200
00037e d294
00037f d29c                      	do_lcd_data ' '
000380 e40d
000381 d291
000382 d299                      	do_lcd_data 'M'
000383 e60f
000384 d28e
000385 d296                      	do_lcd_data 'o'
000386 e604
000387 d28b
000388 d293                      	do_lcd_data 'd'
000389 e605
00038a d288
00038b d290                      	do_lcd_data 'e'
00038c e200
00038d d285
00038e d28d                      	do_lcd_data ' '
                                 
00038f e021                      	ldi temp2, 1
000390 9320 0209                 	sts numPressed, temp2		;load in first item
000392 930f
000393 931f
000394 932f
000395 b70f
000396 930f
000397 e0d2
000398 e0ce
000399 2722
00039a 2f02
00039b 950a
00039c 3000
00039d f041
00039e 0f00
00039f 950a
0003a0 9119
0003a1 8118
0003a2 1702
0003a3 f011
0003a4 9523
0003a5 cffa
0003a6 8118
0003a7 9310 020b
0003a9 9119
0003aa 9310 020c
0003ac 910f
0003ad bf0f
0003ae 912f
0003af 911f
0003b0 910f                      	getInventory temp2
                                 	;lds temp, currentStock
0003b1 b928                      	out portc, temp2
                                 		
                                 
0003b2 5d20                      	subi temp2, -'0'
0003b3 2f02
0003b4 d25e
0003b5 d266                      	do_lcd_data_reg temp2
                                 
0003b6 ea08
0003b7 d254
0003b8 d263                      	do_lcd_command secondLine
0003b9 9120 020b                 	lds temp2, currentStock
0003bb 5d20                      	subi temp2, -'0'
0003bc 2f02
0003bd d255
0003be d25d                      	do_lcd_data_reg temp2
                                 
0003bf e200
0003c0 d252
0003c1 d25a                      	do_lcd_data ' '
0003c2 e200
0003c3 d24f
0003c4 d257                      	do_lcd_data ' '
0003c5 e200
0003c6 d24c
0003c7 d254                      	do_lcd_data ' '
0003c8 e200
0003c9 d249
0003ca d251                      	do_lcd_data ' '
0003cb e200
0003cc d246
0003cd d24e                      	do_lcd_data ' '
0003ce e200
0003cf d243
0003d0 d24b                      	do_lcd_data ' '
0003d1 e200
0003d2 d240
0003d3 d248                      	do_lcd_data ' '
0003d4 e224                      	ldi temp2, 36
0003d5 2f02
0003d6 d23c
0003d7 d244                      	do_lcd_data_reg temp2
                                 
0003d8 9120 020c                 	lds temp2, currentCost
0003da 5d20                      	subi temp2, -'0'
0003db 2f02
0003dc d236
0003dd d23e                      	do_lcd_data_reg temp2
                                 	
0003de 910f
0003df bf0f
0003e0 912f
0003e1 911f
0003e2 910f                      	popTemp	
0003e3 9508                      	ret
                                 
                                 
                                 // MAIN LOOP TO START POLLING
                                 main:
                                 	;lds temp, menu
                                 	
                                 	;do_lcd_command secondLine
                                 
                                 	;do_lcd_data_reg temp
                                 
0003e4 ee6f                      	ldi cmask, INITCOLMASK	; initial column mask
0003e5 2744                      	clr col					; initial column
0003e6 dc49                      	rcall colloop			; continue poll
0003e7 cffc                      	rjmp main				; loop main to continue polling 
                                 
                                 
                                 // TIMER 0 INTERUPT
                                 Timer0OVF: ; interrupt subroutine to Timer0
                                 	
0003e8 930f
0003e9 931f
0003ea 932f
0003eb b70f
0003ec 930f
0003ed 93df
0003ee 93cf
0003ef 939f
0003f0 938f                      	pushStack
                                 	; Load the value of the temporary counter.
0003f1 9180 0204                 	lds r24, TempCounter
0003f3 9190 0205                 	lds r25, TempCounter+1
0003f5 9601                      	adiw r25:r24, 1 ; Increase the temporary counter by one.
                                 
0003f6 3a81                      	cpi r24, low(1953) ; Check if (r25:r24) = 7812
0003f7 e007                      	ldi temp, high(1953) ; 7812 = 10^6/128
0003f8 0790                      	cpc r25, temp
0003f9 f5a1                      	brne NotSecond //not 0.25 seconds
                                 	// Execute every 0.25 sec
                                 	timer1flag:
0003fa 9100 0200
0003fc 3001                      		checkIfMenu 1
0003fd f441                      		brne timer6flag
0003fe 9100 0206                 		lds temp, timer1
                                 
000400 3000                      		cpi temp, 0
000401 f189                      		breq callSelectScreen ;change later
000402 950a                      		dec temp
000403 9300 0206                 		sts timer1, temp
000405 c033                      		rjmp newQsecond
                                 	
                                 	timer6flag:
000406 9100 0200
000408 3002                      		checkIfMenu 2		;admin mode can only be entered in menu 2
000409 f461                      		brne timer3flag		;ELSE move on
                                 
00040a 9100 020a                 		lds temp, prevNum   ;only enter loop if '*' is pressed
00040c 320a                      		cpi temp, '*'
00040d f441                      		brne timer3flag
                                 
00040e 9100 0208                 		lds temp, timer6       ;load timer 6 = 20 = 5secs
                                 
000410 3000                      		cpi temp, 0			   ;when timer runs down to 0, decrement
000411 f121                      		breq callAdminMode 
                                 		;out portc, temp ; DEBUG DISPLAY TIMER6, (IT WORKS)
000412 950a                      		dec temp
000413 9300 0208                 		sts timer6, temp
000415 c023                      		rjmp newQsecond
                                 
                                 	timer3flag:
000416 9100 0200
000418 3003                      		checkIfMenu 3 ;check if in out of stock screen
000419 f529                      		brne epilogue
00041a 9100 0207                 		lds temp, timer3
                                 		;out portc, temp
00041c 3000                      		cpi temp, 0
00041d f0a9                      		breq callSelectScreen ;change later
                                 	
                                 		//FLASH LEDS
00041e 2f20                      		mov temp2, temp //load time into temp
00041f 7021                      		andi temp2, 0b00000001 //and to get either a 1 or 0 in the last bit
000420 3020                      		cpi temp2, 0 //0 = even, 1 = odd
000421 f441                      		brne continue //If odd skip
000422 ef1f                      		ser temp1
000423 9120 020d                 		lds temp2, pattern
000425 2721                      		eor temp2, temp1 //Invert pattern
000426 9320 020d                 		sts pattern, temp2
000428 b928                      		out portc, temp2
000429 bb24                      		out portg, temp2
                                 
                                 		continue:
00042a 950a                      		dec temp
                                 		;out portc, temp
00042b 9300 0207                 		sts timer3, temp
00042d c00b                      		rjmp newQsecond
                                 
                                 	NotSecond:
                                 	; Store the new value of the temporary counter.
00042e 9380 0204                 	sts TempCounter, r24
000430 9390 0205                 	sts TempCounter+1, r25
000432 c00c                      	rjmp epilogue
                                 
                                 	callSelectScreen:
000433 e00f                      		ldi temp, 0b00001111
                                 		;out portc, temp
000434 de38                      		rcall selectScreen
000435 c009                      		rjmp epilogue
                                 
                                 	callAdminMode:
000436 e505                      		ldi temp, 0b01010101
                                 		;out portc, temp
000437 df14                      		rcall enterAdminMode
000438 c006                      		rjmp epilogue
                                 
                                 /*	if(menu == 1 || menu == 3)
                                 		use timer1 (3 seconds)
                                 	else if (menu == 2)
                                 		use timer2 (5 seconds)*/
                                 
                                 
                                 
                                 newQsecond: ;starts new quarter 
000439 e0c4
00043a e0d2
00043b 2700
00043c 9309
00043d 8308                      	clear TempCounter ; Reset the temporary counter.
00043e c000                      	rjmp epilogue
                                 
                                 
                                 epilogue:
00043f e000                      	ldi temp, 0
                                 ;	out portc, temp
000440 918f
000441 919f
000442 91cf
000443 91df
000444 910f
000445 bf0f
000446 912f
000447 911f
000448 910f                      	popStack
000449 9518                      	reti ; Return from the interrupt.
                                 
                                 
                                 // PUSH BUTTON INTERUPTS :)
                                 EXT_INT0: ;Right Button
00044a 930f
00044b 931f
00044c 932f
00044d b70f
00044e 930f
00044f 93df
000450 93cf
000451 939f
000452 938f                      	pushStack
000453 2700                      	clr temp
000454 b908                      	out PORTC, temp
000455 bb04                      	out PORTG, temp
                                 	/*cpi debounceFlag0, 1 ;if still debouncing, ignore interupt
                                 	breq END_INT0 
                                 
                                 	ldi debounceFlag0, 1 ;set debounce flag*/
000456 9100 0200
000458 3006                      	checkIfMenu 6
000459 f041                      	breq incStock
                                 	
00045a 9100 0200
00045c 3003                      	checkIfMenu 3  ;if menu = 3, go back to select screen 
00045d f401                      	brne endBridge0
                                 endBridge0:
00045e 940c 04e7                 	jmp END_INT0
                                 
000460 de0c                      	rcall selectScreen
000461 c19f                      	rjmp END_INT1
                                 incStock:
000462 930f
000463 931f
000464 932f
000465 b70f
000466 930f
000467 9120 020b
000469 302a
00046a f021
00046b 9523
00046c 9320 020b
00046e 8328
00046f 910f
000470 bf0f
000471 912f
000472 911f
000473 910f                      	increaseStock
000474 930f
000475 931f
000476 932f
000477 b70f
000478 930f
000479 e308
00047a d191
00047b d1a0
00047c d1b9
00047d e308
00047e d18d
00047f d19c
000480 d1ac
000481 e308
000482 d189
000483 d198
000484 e308
000485 d186
000486 d195
000487 e008
000488 d183
000489 d192
00048a e001
00048b d180
00048c d18f
00048d e006
00048e d17d
00048f d18c
000490 e00c
000491 d17a
000492 d189
000493 e401
000494 d17e
000495 d186
000496 e604
000497 d17b
000498 d183
000499 e60d
00049a d178
00049b d180
00049c e609
00049d d175
00049e d17d
00049f e60e
0004a0 d172
0004a1 d17a
0004a2 e200
0004a3 d16f
0004a4 d177
0004a5 e40d
0004a6 d16c
0004a7 d174
0004a8 e60f
0004a9 d169
0004aa d171
0004ab e604
0004ac d166
0004ad d16e
0004ae e605
0004af d163
0004b0 d16b
0004b1 e200
0004b2 d160
0004b3 d168
0004b4 9100 0209
0004b6 5d00
0004b7 2f00
0004b8 d15a
0004b9 d162
0004ba ea08
0004bb d150
0004bc d15f
0004bd 9100 020b
0004bf 5d00
0004c0 2f00
0004c1 d151
0004c2 d159
0004c3 e200
0004c4 d14e
0004c5 d156
0004c6 e200
0004c7 d14b
0004c8 d153
0004c9 e200
0004ca d148
0004cb d150
0004cc e200
0004cd d145
0004ce d14d
0004cf e200
0004d0 d142
0004d1 d14a
0004d2 e200
0004d3 d13f
0004d4 d147
0004d5 e200
0004d6 d13c
0004d7 d144
0004d8 e204
0004d9 2f00
0004da d138
0004db d140
0004dc 9100 020c
0004de 5d00
0004df 2f00
0004e0 d132
0004e1 d13a
0004e2 910f
0004e3 bf0f
0004e4 912f
0004e5 911f
0004e6 910f                      	updateAdminScreen
                                 END_INT0:
0004e7 918f
0004e8 919f
0004e9 91cf
0004ea 91df
0004eb 910f
0004ec bf0f
0004ed 912f
0004ee 911f
0004ef 910f                      	popStack
0004f0 9518                      	reti
                                 
                                 EXT_INT1: ;Left Button
0004f1 930f
0004f2 931f
0004f3 932f
0004f4 b70f
0004f5 930f
0004f6 93df
0004f7 93cf
0004f8 939f
0004f9 938f                      	pushStack
0004fa 2700                      	clr temp
0004fb b908                      	out PORTC, temp
0004fc bb04                      	out PORTG, temp
                                 	/*cpi debounceFlag0, 1 ;if still debouncing, ignore interupt
                                 	breq END_INT0 
                                 
                                 	ldi debounceFlag0, 1 ;set debounce flag*/
0004fd 9100 0200
0004ff 3006                      	checkIfMenu 6
000500 f041                      	breq decStock
000501 9100 0200
000503 3003                      	checkIfMenu 3  ;if menu = 3, go back to select screen 
000504 f401                      	brne endBridge1
                                 endBridge1:
000505 940c 0601                 	jmp END_INT1
000507 dd65                      	rcall selectScreen
000508 c0f8                      	rjmp END_INT1
                                 decStock:
000509 930f
00050a 931f
00050b 932f
00050c b70f
00050d 930f
00050e e308
00050f d0fc
000510 d10b
000511 d124
000512 e308
000513 d0f8
000514 d107
000515 d117
000516 e308
000517 d0f4
000518 d103
000519 e308
00051a d0f1
00051b d100
00051c e008
00051d d0ee
00051e d0fd
00051f e001
000520 d0eb
000521 d0fa
000522 e006
000523 d0e8
000524 d0f7
000525 e00c
000526 d0e5
000527 d0f4
000528 e401
000529 d0e9
00052a d0f1
00052b e604
00052c d0e6
00052d d0ee
00052e e60d
00052f d0e3
000530 d0eb
000531 e609
000532 d0e0
000533 d0e8
000534 e60e
000535 d0dd
000536 d0e5
000537 e200
000538 d0da
000539 d0e2
00053a e40d
00053b d0d7
00053c d0df
00053d e60f
00053e d0d4
00053f d0dc
000540 e604
000541 d0d1
000542 d0d9
000543 e605
000544 d0ce
000545 d0d6
000546 e200
000547 d0cb
000548 d0d3
000549 9100 0209
00054b 5d00
00054c 2f00
00054d d0c5
00054e d0cd
00054f ea08
000550 d0bb
000551 d0ca
000552 9100 020b
000554 5d00
000555 2f00
000556 d0bc
000557 d0c4
000558 e200
000559 d0b9
00055a d0c1
00055b e200
00055c d0b6
00055d d0be
00055e e200
00055f d0b3
000560 d0bb
000561 e200
000562 d0b0
000563 d0b8
000564 e200
000565 d0ad
000566 d0b5
000567 e200
000568 d0aa
000569 d0b2
00056a e200
00056b d0a7
00056c d0af
00056d e204
00056e 2f00
00056f d0a3
000570 d0ab
000571 9100 020c
000573 5d00
000574 2f00
000575 d09d
000576 d0a5
000577 910f
000578 bf0f
000579 912f
00057a 911f
00057b 910f                      	updateAdminScreen
                                 
00057c 930f
00057d 931f
00057e 932f
00057f b70f
000580 930f
000581 9120 020b
000583 3020
000584 f021
000585 952a
000586 9320 020b
000588 8328
000589 910f
00058a bf0f
00058b 912f
00058c 911f
00058d 910f                      	decreaseStock 
00058e 930f
00058f 931f
000590 932f
000591 b70f
000592 930f
000593 e308
000594 d077
000595 d086
000596 d09f
000597 e308
000598 d073
000599 d082
00059a d092
00059b e308
00059c d06f
00059d d07e
00059e e308
00059f d06c
0005a0 d07b
0005a1 e008
0005a2 d069
0005a3 d078
0005a4 e001
0005a5 d066
0005a6 d075
0005a7 e006
0005a8 d063
0005a9 d072
0005aa e00c
0005ab d060
0005ac d06f
0005ad e401
0005ae d064
0005af d06c
0005b0 e604
0005b1 d061
0005b2 d069
0005b3 e60d
0005b4 d05e
0005b5 d066
0005b6 e609
0005b7 d05b
0005b8 d063
0005b9 e60e
0005ba d058
0005bb d060
0005bc e200
0005bd d055
0005be d05d
0005bf e40d
0005c0 d052
0005c1 d05a
0005c2 e60f
0005c3 d04f
0005c4 d057
0005c5 e604
0005c6 d04c
0005c7 d054
0005c8 e605
0005c9 d049
0005ca d051
0005cb e200
0005cc d046
0005cd d04e
0005ce 9100 0209
0005d0 5d00
0005d1 2f00
0005d2 d040
0005d3 d048
0005d4 ea08
0005d5 d036
0005d6 d045
0005d7 9100 020b
0005d9 5d00
0005da 2f00
0005db d037
0005dc d03f
0005dd e200
0005de d034
0005df d03c
0005e0 e200
0005e1 d031
0005e2 d039
0005e3 e200
0005e4 d02e
0005e5 d036
0005e6 e200
0005e7 d02b
0005e8 d033
0005e9 e200
0005ea d028
0005eb d030
0005ec e200
0005ed d025
0005ee d02d
0005ef e200
0005f0 d022
0005f1 d02a
0005f2 e204
0005f3 2f00
0005f4 d01e
0005f5 d026
0005f6 9100 020c
0005f8 5d00
0005f9 2f00
0005fa d018
0005fb d020
0005fc 910f
0005fd bf0f
0005fe 912f
0005ff 911f
000600 910f                      	updateAdminScreen
                                 
                                 END_INT1:
000601 918f
000602 919f
000603 91cf
000604 91df
000605 910f
000606 bf0f
000607 912f
000608 911f
000609 910f                      	popStack
00060a 9518                      	reti
                                 
                                 
                                 halt:
00060b cfff                      	rjmp halt
                                 
                                 	
                                 .include "lcd.asm"
                                 
                                 
                                 
                                 .equ LCD_RS = 7
                                 .equ LCD_E = 6
                                 .equ LCD_RW = 5
                                 .equ LCD_BE = 4
                                 
                                 .macro lcd_set
                                 	sbi PORTA, @0
                                 .endmacro
                                 .macro lcd_clr
                                 	cbi PORTA, @0
                                 .endmacro
                                 ;
                                 ; Send a command to the LCD (r16)
                                 ;
                                 
                                 lcd_command:
00060c bb01                      	out PORTF, r16
00060d d01f                      	rcall sleep_1ms
00060e 9a16                      	lcd_set LCD_E
00060f d01d                      	rcall sleep_1ms
000610 9816                      	lcd_clr LCD_E
000611 d01b                      	rcall sleep_1ms
000612 9508                      	ret
                                 
                                 lcd_data:
000613 bb01                      	out PORTF, r16
000614 9a17                      	lcd_set LCD_RS
000615 d017                      	rcall sleep_1ms
000616 9a16                      	lcd_set LCD_E
000617 d015                      	rcall sleep_1ms
000618 9816                      	lcd_clr LCD_E
000619 d013                      	rcall sleep_1ms
00061a 9817                      	lcd_clr LCD_RS
00061b 9508                      	ret
                                 
                                 lcd_wait:
00061c 930f                      	push r16
00061d 2700                      	clr r16
00061e bb00                      	out DDRF, r16
00061f bb01                      	out PORTF, r16
000620 9a15                      	lcd_set LCD_RW
                                 lcd_wait_loop:
000621 d00b                      	rcall sleep_1ms
000622 9a16                      	lcd_set LCD_E
000623 d009                      	rcall sleep_1ms
000624 b10f                      	in r16, PINF
000625 9816                      	lcd_clr LCD_E
000626 fd07                      	sbrc r16, 7
000627 cff9                      	rjmp lcd_wait_loop
000628 9815                      	lcd_clr LCD_RW
000629 ef0f                      	ser r16
00062a bb00                      	out DDRF, r16
00062b 910f                      	pop r16
00062c 9508                      	ret
                                 
                                 .equ F_CPU = 16000000
                                 .equ DELAY_1MS = F_CPU / 4 / 1000 - 4
                                 ; 4 cycles per iteration - setup/call-return overhead
                                 
                                 sleep_1ms:
00062d 938f                      	push r24
00062e 939f                      	push r25
00062f e09f                      	ldi r25, high(DELAY_1MS)
000630 e98c                      	ldi r24, low(DELAY_1MS)
                                 delayloop_1ms:
000631 9701                      	sbiw r25:r24, 1
000632 f7f1                      	brne delayloop_1ms
000633 919f                      	pop r25
000634 918f                      	pop r24
000635 9508                      	ret
                                 
                                 sleep_5ms:
000636 dff6                      	rcall sleep_1ms
000637 dff5                      	rcall sleep_1ms
000638 dff4                      	rcall sleep_1ms
000639 dff3                      	rcall sleep_1ms
00063a dff2                      	rcall sleep_1ms
00063b 9508                      


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega2560" register use summary:
x  :   0 y  :  40 z  :   0 r0 :   0 r1 :   0 r2 :   0 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   0 r14:   0 r15:   0 r16: 578 r17:  65 r18:  85 r19:   7 r20:   7 
r21:   3 r22:   3 r23:  20 r24:  14 r25:  14 r26:   0 r27:   0 r28:  13 
r29:  13 r30:   0 r31:   0 
Registers used: 13 out of 35 (37.1%)

"ATmega2560" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   0 add   :   3 adiw  :   1 and   :   1 
andi  :   2 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   0 brcs  :   0 break :   0 breq  :  32 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 brlt  :   0 brmi  :   0 
brne  :  15 brpl  :   0 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   5 cbr   :   0 
clc   :   0 clh   :   0 cli   :   0 cln   :   0 clr   :  13 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   0 cp    :   3 cpc   :   1 
cpi   :  41 cpse  :   0 dec   :  12 eicall:   0 eijmp :   0 elpm  :   0 
eor   :   1 fmul  :   0 fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   0 
in    :  17 inc   :   7 jmp   :  22 ld    :  12 ldd   :   0 ldi   : 304 
lds   :  48 lpm   :   0 lsl   :   6 lsr   :   0 mov   :  28 movw  :   0 
mul   :   0 muls  :   0 mulsu :   0 neg   :   0 nop   :   0 or    :   0 
ori   :   2 out   :  42 pop   :  75 push  :  75 rcall : 552 ret   :  11 
reti  :   3 rjmp  :  22 rol   :   0 ror   :   0 sbc   :   0 sbci  :   0 
sbi   :   5 sbic  :   0 sbis  :   0 sbiw  :   1 sbr   :   0 sbrc  :   1 
sbrs  :   0 sec   :   0 seh   :   0 sei   :   1 sen   :   0 ser   :   3 
ses   :   0 set   :   0 sev   :   0 sez   :   0 sleep :   0 spm   :   0 
st    :  26 std   :   2 sts   :  36 sub   :   1 subi  :  18 swap  :   0 
tst   :   0 wdr   :   0 
Instructions used: 39 out of 116 (33.6%)

"ATmega2560" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000c78   3112      0   3112  262144   1.2%
[.dseg] 0x000200 0x000220      0     32     32    8192   0.4%
[.eseg] 0x000000 0x000000      0      0      0    4096   0.0%

Assembly complete, 0 errors, 0 warnings
